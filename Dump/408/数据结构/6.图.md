完全图：任意两个顶点都存在边

生成子图：顶点是原图，边是原图子集

连通图：任意两点是连通的

无向图的极大联通子图称为联通分量

# 图的存储

## 邻接矩阵

二维数组存边

适合稠密图

## 邻接表

每个顶点建立一个单链表，边表存储邻接点

# 图的遍历

## 广度优先搜索BFS

起始点入队，出队访问并标记，把访问的点的未标记邻接点入队，重复

## 深度优先搜索DFS

起始点入栈，出栈访问并标记，把访问的点的未标记邻接点入栈，重复

# 图的应用

## 最小生成树

### Prim算法

初始时从图中任取一顶点加入树T，之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1。以此类推直至图中所有的顶点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边。

### kruskal算法

把每个顶点看成一个连通分量，然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入T。以此类推，直至T中所有顶点都在一个连通分量上。

## 最短路径

### Dijkstra算法单源最短路

首先设置集合S是已求得的最短路径的顶点，设数组D存放源点到其他点的最短路径长度，初始化为源点到该点相连的边的权值，若没有则设为无穷。然后从集合S以外选一点j满足D[j]最小，此时已经找到源点到j点的最短距离，把j加入集合S，然后依次用j点松弛源点到集合S外的各点距离。

不适用于负权边

O(V^2^)

### Floyd算法求各顶点直接最短路

有n个节点，不断用1到n的节点尝试作为中间节点缩短各顶点之间的距离

O(V^3^)