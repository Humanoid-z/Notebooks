![image-20210821194041084](https://raw.githubusercontent.com/SNIKCHS/MDImage/main/img/image-20210821194041084.png)

有序树：树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，

二叉树是有序树

结点的孩子个数称为该节点的度，树中结点的最大度数称为树的度

**满二叉树**的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为2

完全二叉树：节点排列从上到下从左到右，一层排满了排到下一层。左孩子节点编号是双亲节点的编号2倍，右节点是2倍+1

二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又是一棵二叉排序树。

平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1

# 二叉树的遍历和线索二叉树

先序遍历

1)访问根结点;

2)先序遍历左子树;

3)先序遍历右子树。

中序遍历

1)中序遍历左子树;

2)访问根结点;

3)中序遍历右子树。

后序遍历

1)后序遍历左子树;

2)后序遍历右子树。

3)访问根结点;

## 由遍历序列构造二叉树

由二叉树的先序序列和中序序列可以唯一地确定一棵二叉树。

先序遍历序列中，第一个结点一定是二叉树的根结点;而在**中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列**。

后序序列和中序序列也可以唯一地确定一棵二叉树。

后序序列的最后一个结点就如同先序序列的第一个结点，可以将中序序列分割成两个子序列，然后采用类似的方法递归地进行划分，进而得到一棵二叉树

## 树的存储结构

双亲表示法

采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。

<img src="https://raw.githubusercontent.com/SNIKCHS/MDImage/main/img/image-20210821204849858.png" alt="image-20210821204849858" style="zoom:67%;" />

孩子表示法

孩子表示法是将每个结点的孩子结点都用单链表链接起来形成一个线性结构

<img src="https://raw.githubusercontent.com/SNIKCHS/MDImage/main/img/image-20210821204944210.png" alt="image-20210821204944210" style="zoom:67%;" />

孩子兄弟表示法又称二叉树表示法，即以二叉链表作为树的存储结构。孩子兄弟表示法使每个结点包括三部分内容:结点值、指向结点第一个孩子结点的指针，及指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点)

![image-20210821205037422](https://raw.githubusercontent.com/SNIKCHS/MDImage/main/img/image-20210821205037422.png)

## 树、森林与二叉树的转换

树转换为二叉树的规则:**每个结点左指针指向它的第一个孩子,右指针指向它在树中的相邻右兄弟，.这个规则又称“左孩子右兄弟"**。

将森林中的每棵树转换成相应的二叉树；每棵树的根也可视为兄弟关系

# 树和二叉树的应用

# 二叉排序树（BST）

1. 若左子树非空，则左子树上所有结点的值均小于根结点的值。
2. 若右子树非空，则右子树上所有结点的值均大于根结点的值。
3. 左、右子树也分别是一棵二叉排序树。

**对二叉排序树进行中序遍历，可以得到一个递增的有序序列**。

## 平衡二叉树

左、右子树高度差的绝对值不超过1

## 哈夫曼树（最优二叉树）

带权路径长度最短

1. n 个结点分别作为n 棵仅含一个结点的二叉树，构成森林F.
2. 构造一个新结点，从F 中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和
3. 从F 中删除刚才挑出的两棵树，同时将新得到的树加入F 中。

哈夫曼编码描述一下实现过程

每个字符作为一个节点，出现的频率作为节点的权值，构造一个哈夫曼树，然后左子树对应的边写0，右子树对应的边写1，从根节点到叶节点的路径按顺序就构成了哈夫曼编码。没有一个编码是另一个编码的前缀。