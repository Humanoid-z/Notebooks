# 11.1  并发控制概述

事务是并发控制的**基本单位**

并发控制机制的任务

- 对并发操作进行正确调度
- 保证事务的隔离性
- 保证数据库的一致性

并发操作带来的数据不一致性
1.丢失修改（Lost Update）

- 两个事务T1和T2读入同一数据并修改，T2的提交结果破坏了T1提交的结果，导致T1的修改被丢失

2.不可重复读（Non-repeatable Read）

- 不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。

- 不可重复读包括三种情况：
  （1）事务T1读取某一数据后，**事务T2对其做了修改**，当事务T1再次读该数据时，得到与前一次不同的值 

  （2）事务T1按一定条件从数据库中读取了某些数据记录后，**事务T2删除了其中部分记录**，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了。 
  （3）事务T1按一定条件从数据库中读取某些数据记录后，**事务T2插入了一些记录**，当T1再次按相同条件读取数据时，发现多了一些记录。
       后两种不可重复读有时也称为幻影现象

3.读“脏”数据（Dirty Read）

- 读“脏”数据是指：
  - 事务T1修改某一数据，并将其写回磁盘
  - 事务T2读取同一数据后，T1由于某种原因被撤销
  - 这时T1已修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致
  - T2读到的数据就为“脏”数据，即不正确的数据

记号

R(x):读数据x
W(x):写数据x 

数据不一致性：由于**并发操作破坏了事务的隔离性**
并发控制就是要用**正确的方式调度并发操作**，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性 
对数据库的应用有时允许某些不一致性

# 11.2  封锁

什么是封锁

- 封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁
- 加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。
- 封锁是实现并发控制的一个非常重要的技术

一个事务对某个数据对象加锁后究竟拥有什么样的控制由封锁的类型决定。
基本封锁类型
排它锁（Exclusive Locks，简记为X锁）
共享锁（Share Locks，简记为S锁）

**排它锁**

- 排它锁又称为写锁
- 若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁
- 保证其他事务在T释放A上的锁之前不能再读取和修改A 

**共享锁**

- 共享锁又称为读锁
- 若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁
- 保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改 

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\数据库\第十一章  并发控制.assets\image-20201220203118111.png" alt="image-20201220203118111" style="zoom:67%;" />

# 11.3  封锁协议

在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。 

- 何时申请X锁或S锁
- 持锁时间
- 何时释放

1.一级封锁协议

事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。

正常结束（COMMIT）
非正常结束（ROLLBACK）

一级封锁协议**可防止丢失修改**，并保证事务T是可恢复的。
在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它**不能保证可重复读和不读“脏”数据**。

2.二级封锁协议

一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。

二级封锁协议**可以防止丢失修改和读“脏”数据**。

在二级封锁协议中，由于读完数据后即可释放S锁，所以它**不能保证可重复读**。

3.三级封锁协议

一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。

三级封锁协议**可防止丢失修改、读脏数据和不可重复读**。

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\数据库\第十一章  并发控制.assets\image-20201220204125004.png" alt="image-20201220204125004" style="zoom:67%;" />

# 11.4  活锁和死锁

**活锁**

事务T1封锁了数据R
事务T2又请求封锁R，于是T2等待。
T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待。
T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……
T2有可能永远等待，这就是活锁的情形 

避免活锁：采用**先来先服务**的策略

当多个事务请求封锁同一数据对象时

按请求封锁的先后次序对这些事务排队

该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁

**死锁**

不同事务互相等待对方已经封锁的数据解锁，造成永远等待的情况

解决死锁的方法

1. 死锁的预防

   预防死锁的方法
   （1）一次封锁法

   ​		要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能	继续执行
   ​	存在的问题：降低系统并发度

   难于事先精确确定封锁对象
   数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象。
   解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。

   （2）顺序封锁法

   顺序封锁法是预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。
   顺序封锁法存在的问题
   维护成本
       数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，成本很高。
   难以实现
       事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就很难按规定的顺序去施加封锁 

2. 死锁的诊断与解除

   数据库管理系统在解决死锁的问题上更普遍采用的是诊断并解除死锁的方法

   死锁的诊断
   （1）超时法

   ​	如果一个事务的等待时间超过了规定的时限，就认为发生了死锁
   优点：实现简单
   缺点
   有可能误判死锁
   时限若设置得太长，死锁发生后不能及时发现

   （2）等待图法 

   用事务等待图动态反映所有事务的等待情况
   事务等待图是一个有向图G=(T，U)
   T为结点的集合，每个结点表示正运行的事务
   U为边的集合，每条边表示事务等待的情况
   若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2

   并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。

   解除死锁
   
   选择一个处理死锁代价最小的事务，将其撤消
   释放此事务持有的所有的锁，使其它事务能继续运行下去

# 11.5  并发调度的可串行性

- 数据库管理系统对并发事务不同的调度可能会产生不同的结果
- 串行调度是正确的
- 执行结果等价于串行调度的调度也是正确的，称为可串行化调度

## 11.5.1 可串行化调度

可串行化(Serializable)调度

- 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同

可串行性(Serializability)

- 是并发事务正确调度的准则
- 一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度 

## 11.5.2 冲突可串行化调度

冲突可串行化

- 一个比可串行化更严格的条件
- 商用系统中的调度器采用

冲突操作：是指不同的事务对同一数据的读写操作和写写操作：

  	  Ri(x)与Wj(x)	       /\*事务Ti读x，Tj写x，其中i≠j\*/
	  Wi(x)与Wj(x)         /\*事务Ti写x，Tj写x，其中i≠j*/

其他操作是不冲突操作

不能交换（Swap）的动作:

- 同一事务的两个操作
- 不同事务的冲突操作

一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是**冲突可串行化**的调度
若一个调度是冲突可串行化，则一定是可串行化的调度
可用这种方法判断一个调度是否是冲突可串行化的

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\数据库\第十一章  并发控制.assets\image-20201220211708744.png" alt="image-20201220211708744" style="zoom:80%;" />

冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。

# 11.6  两段锁协议

数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性 

两段锁协议
指所有事务必须分两个阶段对数据项加锁和解锁 

- 在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁
- 在释放一个封锁之后，事务不再申请和获得任何其他封锁

“两段”锁的含义
事务分为两个阶段
 第一阶段是获得封锁，也称为扩展阶段
事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁 
 第二阶段是释放封锁，也称为收缩阶段
事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁 

事务遵守两段锁协议是可串行化调度的**充分条件**，而不是必要条件。
若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的
若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议

两段锁协议与防止死锁的一次封锁法

- 一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议
- 但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁

# 11.7  封锁的粒度

封锁对象的大小称为封锁粒度(Granularity) 
封锁的对象:逻辑单元，物理单元 
     例：在关系数据库中，封锁对象：
逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等
物理单元：页（数据页或索引页）、物理记录等

选择封锁粒度原则

封锁粒度与系统的并发度和并发控制的开销密切相关。

- 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；
- 封锁的粒度越小，并发度较高，但系统开销也就越大

多粒度封锁(Multiple Granularity Locking)
    在一个系统中同时支持多种封锁粒度供不同的事务选择

选择封锁粒度
     同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度

- 需要处理多个关系的大量元组的用户事务：以数据库为封锁单位
- 需要处理大量元组的用户事务：以关系为封锁单元
- 只处理少量元组的用户事务：以元组为封锁单位

## 11.7.1 多粒度封锁

多粒度树

- 以树形结构来表示多级封锁粒度
- 根结点是整个数据库，表示最大的数据粒度
- 叶结点表示最小的数据粒度

允许多粒度树中的每个结点被独立地加锁

对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁

在多粒度封锁中一个数据对象可能以两种方式封锁：**显式封锁和隐式封锁**

显式封锁: 直接加到数据对象上的封锁

隐式封锁:是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁

显式封锁和隐式封锁的效果是一样的

对某个数据对象加锁，系统要检查

-  该数据对象
  - 有无显式封锁与之冲突
-  所有上级结点
  - 检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突：(由上级结点已加的封锁造成的）
- 所有下级结点
  - 看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突

## 11.7.2 意向锁

引进意向锁（intention lock）目的

- 提高对某个数据对象加锁时系统的检查效率

如果对一个结点加意向锁，则说明该结点的**下层结点**正在被加锁

对任一结点加基本锁，必须**先**对它的上层结点**加意向锁**

常用意向锁

意向共享锁(Intent Share Lock，简称IS锁)
意向排它锁(Intent Exclusive Lock，简称IX锁)
共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)

IS锁
如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。

IX锁
如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。

SIX锁
如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\数据库\第十一章  并发控制.assets\image-20201220215000143.png" alt="image-20201220215000143" style="zoom:80%;" />

锁的强度
锁的强度是指它对其他锁的排斥程度
一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\数据库\第十一章  并发控制.assets\image-20201220215016306.png" alt="image-20201220215016306" style="zoom:67%;" />

具有意向锁的多粒度封锁方法
申请封锁时应该按自上而下的次序进行
释放封锁时则应该按自下而上的次序进行