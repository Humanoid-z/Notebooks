# UML Activity Diagram-Based Automatic Test Case Generation For Java Programs

## Summary

Test case generation based on design specifications is an important part of testing processes. In this paper, Unified Modeling Language activity diagrams are used as design specifications. By setting up several test adequacy criteria with respect to activity diagrams, an automatic approach is presented to generate test cases for Java programs. Instead of directly deriving test cases from activity diagrams, this approach selects test cases from a set of randomly generated ones according to a given test adequacy criterion. In the approach, we first instrument a Java program under testing according to its activity diagram model, and randomly generate abundant test cases for the program. Then, by running the instrumented program we obtain the corresponding program execution traces. Finally, by matching these traces with the behavior of the activity diagram, a reduced set of test cases are selected according to the given test adequacy criterion. This approach can also be used to check the consistency between the program execution traces and the behavior of activity diagrams.

基于设计规范的测试用例生成是测试过程的重要组成部分。在本文中，使用统一建模语言活动图作为设计规范。通过建立与活动图相关的几个测试充分性标准，提出了一种自动生成Java程序测试用例的方法。这种方法不是直接从活动图中派生测试用例，而是根据给定的测试充分性标准从一组随机生成的测试用例中选择测试用例。在该方法中，首先根据被测试Java程序的活动图模型对其进行测试，然后**随机生成大量的测试用例**。然后，通过运行被测程序，得到相应的**程序执行轨迹**。最后，通过将这些轨迹与活动图的行为相匹配，根据给定的测试充分性标准选择一个精简的测试用例集。这种方法还可以用来检查程序执行跟踪和活动图的行为之间的一致性。

## 1. Introduction

Testing is an important part of quality assurance in the software life-cycle. As the complexity and the size of software systems grow, more and more time and manpower are required for testing. Manual testing is so labor-intensive and error-prone that it is necessary to employ automatic testing techniques in some circumstances.

大意：测试对于软件的质量保证很重要，但是消耗人力和时间，因此引入自动测试技术

The unified modeling language (UML) is a standard visual modelling language that is designed to specify, visualize, construct and document the artifacts of software systems [1, 2]. Since UML became a standard of OMG in 1997, UML models have become a main class of artifacts in software development processes. UML provides a number of diagrams to describe different aspects of software artifacts. UML activity diagrams describe the sequential or concurrent control flows of activities. They can be used to model the dynamic aspects of a group of objects, or the control flow of an operation, which form a kind of design specifications for programs.

大意：UML很牛

In this paper, we use UML activity diagrams as design specifications, and consider test case generation for Java programs. The state of arts of UML model-based test case generation mainly focuses on generating test cases directly from various UML models by applying specification-based testing and/or code-based testing approaches [3–10]. However, those direct approaches are hardly implemented in a fully automatic fashion because of the following reasons. First, only abstract test cases can directly be generated from the models, which specify the system under constructing. They cannot be used directly in program testing without manual concretization. Second, for dynamic models, the test cases are generated by traversing the paths of models to derive the test scenarios. The loops and branches in the models make the path conditions very complicated. It lead to algorithms with high complexity, even undecidable problems.

大意：考虑如何用UML活动图生成java程序的测试用例，传统的方法是直接从各种UML模型生成测试用例，大部分是通过应用基于规范的测试，或者是基于代码的测试方法(?)，有各种各样的困难。（别人怎么做，有什么问题

In this paper, instead of directly deriving test cases from UML activity diagrams, we present an indirect approach which selects test cases from a set of randomly generated ones according to a given coverage criterion concerning the activity diagram specification. In the approach, we first instrument the Java program under testing according to its activity diagram specification, and randomly generate abundant test cases for the program. Then, by running the program with the generated test cases, we can obtain the corresponding program execution traces. At last, by matching those program execution traces with the behavior of the activity diagram, we can select a reduced set of test cases according to a specific test adequacy criterion. The approach can also be used to check the consistency between the program execution traces and the behavior of activity diagrams.

大意：使用间接手段，在规范内随机生成大量测试用例，运行得到程序执行轨迹，并与活动图的行为相匹配。可以根据特定的测试充分性标准选择一个精简的测试用例集（？）。可以用来检查程序执行跟踪和活动图的行为之间的一致性

The paper is organized as follows. In Section 2, we introduce the UML activity diagrams and the related notations. In Section 3, the approach of automatic test case generation for Java programs is described in detail. The related works are discussed in Section 4, and some conclusions are given in Section 5.

大意：论文组织：在第2节中，介绍UML活动图和相关的符号。在第三部分，详细描述了Java程序测试用例的自动生成方法。第四节对相关工作进行了讨论，第五节给出了一些结论。

## 2. UML ACTIVITY DIAGRAMS

### 2.1 Notations

As opposed to other diagrams in UML, an activity diagram extracts the core idea from flowcharts, state transition graphs and Petri nets [1, 2]. An activity diagram contains activity states, which represent the execution of a statement in a procedure or the performance of an activity in a workflow. Instead of waiting for an event, as in a normal wait state, an activity state waits for the completion of its computation. When the activity completes, the execution proceeds to the next activity state within the diagram. A completion transition in an activity diagram fires when the preceding activities are complete. An activity diagram may contain branches, as well as forking of control into concurrent threads. Concurrent threads represent activities that can be performed concurrently by different objects or persons in an organization.

与UML中的其他图相反，活动图从流程图、状态转换图和Petri网中提取核心思想[1,2]。活动图包含活动状态，活动状态表示过程中语句的执行或工作流中活动的执行。活动状态等待计算完成，而不是像在正常等待状态中那样等待事件。当活动完成时，执行将继续到图中的下一个活动状态。当前面的活动完成时，活动图中的完成转换将触发。活动图可能包含分支，以及将控制分支到并发线程。并发线程表示可以由组织中的不同对象或人员并发执行的活动。

In an activity diagram, an activity state is shown as a box with rounded ends containing a description of the activity; simple completion transitions are shown as arrows; branches are shown as guard conditions on transitions or as diamonds with multiple labeled exit arrows; fork or join of control is shown by multiple arrows leaving or entering a heavy synchronization bar. For example, Fig. 1 shows a simple activity diagram, which consists of most elements to describe a workflow or an operation.

在活动图中，活动状态显示为一个框，该框的圆角两端包含活动的描述;简单的完成转换显示为箭头;分支显示为过渡的保护条件或带有多个标记出口箭头的菱形;控制的分叉或连接由多个离开或进入重同步条的箭头显示。例如，图1显示了一个简单的活动图，它由描述工作流或操作的大多数元素组成。

The recent major revision of UML2.0 has introduced significant changes and additions [2]. Compared with UML1.x, the concrete syntax of activity diagrams remains mostly the same, but the abstract syntax and semantics have changed drastically. In UML1.x, the activity diagrams were defined as a kind of state machine diagrams. Now, there is no connection between these two notations. The meaning of activity diagrams is explained in terms of Petri net notion [11] such as the token, flow, edge weight, etc. In this paper, in accordance with UML2.0, we adopt the Petri net-like semantics of the activity diagrams, and formalize an activity diagram as follows.

UML2.0最近的主要修订引入了重大的变化和添加[2]。相比之下,UML1。X，活动图的具体语法基本保持不变，但抽象语法和语义发生了巨大的变化。在UML1。X，活动图被定义为一种状态机图。这两个符号之间没有联系。活动图的含义是用Petri网概念[11]来解释的，比如令牌、流、边权等。在本文中，根据UML2.0，我们采用活动图的Petri网类语义，**形式化活动图**如下。

In this paper, we consider an activity diagram as a design specification, which describes the workflow of a Java program. Each activity state in the activity diagram is interpreted as the execution of a method in the Java program. For any activity state a, we let ξ(a) denote the corresponding method, and ζ(a) denote the class to which ξ(a) belongs.

大意：在本文中，我们考虑活动图作为设计规范，它描述了一个Java程序的工作流程。活动图中的每个活动状态都被解释为Java程序中方法的执行。对于任何活动状态a， ξ(a)表示对应的方法，ζ(a)表示ξ(a)所属的类。

### 2.2 Paths and trails

In this paper, we are focused on generating test cases for Javaprograms specified by UML activity diagrams. We thus need to consider the test adequacy criteria with respect to activity diagrams. These criteria mainly deal with the test coverage of elements and behavior of a given activity diagram. In a Java program with an activity diagram as its specification, the execution orders of the concurrent methods in different threads, which correspond to the firing orders of the transitions during the run of the activity diagram, are independent of the program inputs. It means that for a given input, the different program executions may result in the different program execution traces, which indicates that the run coverage in an activity diagram is hardly incarnated in the test adequacy criteria. Thus, for defining the test adequacy criteria, instead of runs we introduce paths in activity diagrams as follows.

大意：需要考虑关于活动图的测试充分性标准，这些标准主要处理给定活动图的元素和行为的**测试覆盖率**。不同线程中并发方法的执行顺序(与活动图运行期间转换的触发顺序相对应)独立于程序输入。这意味着对于给定的输入，不同的程序执行可能导致不同的程序执行轨迹，这表明活动图中的运行覆盖很难体现在测试充分性标准中。因此，为了定义测试充分性标准，我们在活动图中引入path，而不是run。

Intuitively, the paths describe the behavior of an activity diagram as if all the transitions separately enabled in a state fire at the same time during the activity diagram execution. For an activity diagram, all the transitions separately enabled in a state form a concurrent transition.

直观地说，这些路径描述了活动图的行为，就好像在活动图执行期间，所有的转换都在一个状态中同时单独启用了一样。对于活动图，在一个状态中单独启用的所有转换形成并发转换。

For an activity diagram, a run is regarded intuitively as a linear execution of a path. Notice that a path could have many linear executions, which means that a path could correspond to many runs. For example, Fig. 2 shows four simple paths s1, s2, s3, s4 in the activity diagram depicted in Fig. 1.

对于活动图，运行被直观地视为路径的线性执行。请注意，一条路径可以有很多次线性执行，这意味着一条路径可以对应很多次运行。例如，图2在图1所示的活动图中显示了四个简单路径s1, s2, s3, s4。

For an activity diagram which models a program, because of the existence of loops we hardly generate test cases to cover its paths fully. It compels us to consider the coverage of simple paths, which contains no repetition. To consider the criteria covering the repetitions of executions and/or specifically selected executions, we need to ==introduce trails== in activity diagrams, which are a sequence of the transitions enabled and firing one by one.

大意：对于一个建模程序的活动图，**由于循环的存在，我们很难生成测试用例来完全覆盖它的路径。它迫使我们考虑简单路径的覆盖范围，其中不包含重复。**为了考虑覆盖重复执行和/或特定选择执行的标准，我们需要在活动图中引入路径，这是一个启用和逐个触发的转换序列。

## 3. APPROACH TO TEST CASE GENERATION FOR JAVA PROGRAMS

In this section, we give the details of the automatic approach to test case generation for Java programs with activity diagrams as design specifications. The approach first instruments a Java program under testing according to its activity diagram model, and randomly generates abundant test cases for the program. Then, by running the instrumented program, we obtain the corresponding program execution traces. At last, by matching these traces with the behavior of the activity diagram, we obtained a reduced set of test cases according to a specific test adequacy criterion.

大意：首先根据被测试Java程序的活动图模型对其进行测试，然后随机生成大量的测试用例。然后，通过运行被测程序，得到相应的程序执行轨迹。最后，通过将这些轨迹与活动图的行为进行匹配，我们根据特定的测试充分性准则得到了一个简化的测试用例集。

### 3.1 Test adequacy criteria with respect to activity diagrams

There have been several works [7, 10, 13] on the test adequacy criteria for UML static models, interaction models and state machine diagrams. Those criteria can be used for model testing or program testing. They mainly deal with the coverage of various elements and paths in UML models, and their basic ideas come from the traditional code coverage criteria. Like those works, the test adequacy criteria we consider here mainly deal with the coverage of elements and paths in a given activity diagram during the execution of a program under testing. The coverage is computed through matching the behavior of the activity diagram with the program execution traces. For an activity diagram, we set up the following four test adequacy criteria.

大意：关于UML静态模型、交互模型和状态机图的测试充分性标准已经有一些工作。这些标准可以用于模型测试或程序测试。它们主要处理UML模型中各种元素和路径的覆盖，它们的基本思想来自于传统的代码覆盖标准。像那些工作一样，我们在这里考虑的测试充分性标准主要处理在测试下的程序执行期间给定活动图中的元素和路径的覆盖率。覆盖率是通过将活动图的行为与程序执行轨迹相匹配来计算的。对于一个活动图，我们建立以下四个测试充分性标准。

1. Activity coverage requires that all activity states in the activity diagram be covered.
2. Transition coverage requires that all the transitions in the activity diagram be covered.
3. Simple path coverage requires that all the simple paths in the activity diagram be covered.
4. Trail coverage requires that all the given trails in the activity diagram be covered.

The activity coverage and transition coverage are basic coverage criteria and easily satisfied in testing, just like the statement coverage in the code coverage criteria. The simple path coverage is essentially based on a partial order of behavior of an activity diagram. It avoids the indeterminacy caused by concurrency, but does not cover any repetition of execution. The trail coverage deals with some special executions (including the repetitions of executions) in an activity diagrams which should be covered in testing, but the trails are usually picked out manually.

活动覆盖率和转换覆盖率是基本的覆盖率标准，在测试中很容易得到满足，就像代码覆盖率标准中的语句覆盖率一样。简单路径覆盖基本上是基于活动图的部分行为顺序。它避免了并发性引起的不确定性，但不包括任何重复执行。轨迹覆盖处理活动图中一些特殊的执行(包括执行的重复)，这些执行应该在测试中覆盖，但是轨迹通常是手工挑选的。

### 3.2 Program instrumenting

For a Java program under testing, we need to insert some statements into its source code for gathering the program execution traces. As each activity state in an activity diagram is interpreted as the execution of one method in a Java program, the program execution traces we gather are a sequence of events corresponding to method completions.

对于正在测试的Java程序，我们需要在其源代码中插入一些语句，以收集程序执行跟踪。由于活动图中的每个活动状态都被解释为Java程序中一个方法的执行，所以我们收集的程序执行跟踪是与方法完成相对应的一系列事件。

During the execution of a Java program, a class may have multiple instances. The same method of different instances may be invoked. This causes a trouble because we cannot identify which object’s method in a program execution trace is corresponding to a given activity diagram. Therefore, we assume that any Java program under testing, specified by an activity diagram D, is such that for any activity state a in D, z(a) (i.e. the class with the method corresponds to a) has just one instance during the program execution.

大意：在Java程序执行期间，一个类可能有多个实例。可以调用不同实例的相同方法。这将导致一个问题，因为我们不能确定程序执行跟踪中的哪个对象的方法与给定的活动图相对应。因此，我们假设任何正在测试的Java程序，由活动图D指定，对于D中的任何活动状态a, ζ(a)(即具有对应于a的方法的类)在程序执行期间只有一个实例。

Because we use the activity diagrams as the global behavior model of software systems, usually only high-level components of the system are concerned in such activity diagrams. Although most classes in an object-oriented software system may have many instances, which are created and destroyed dynamically, the high-level components are generally stable, and most of them are the only instance of their corresponding classes. Therefore the above assumption does not narrow the applicability of our approach much. In case that this assumption is not satisfied, our approach may still be applicable after rewriting the activity diagram with a coarser granularity or renaming the related classes in the program.

大意：尽管面向对象软件系统中的大多数类可能有许多实例，这些实例是动态创建和销毁的，但高级组件通常是稳定的，而且它们中的大多数是对应类的唯一实例。因此，上述假设具有实用性

In a Java program, a method finishes its computation after the execution of its last statement. Thus, we insert the statements for gathering the information in the end of each related method definition. Given an activity diagram D = (A, T, F, a~I~, a~F~), for any a∈A, when its corresponding method ξ(a) finishes its computation, the information we need to log includes the method ξ(a) itself and the class ζ(a) which ξ(a) is in. The instrumentation algorithm depicted in Fig. 3 runs as follows. First it scans the program and parses

大意：在每个相关方法定义的末尾插入用于收集信息的语句，需要log的信息包括ξ(A)方法本身和ξ(A)所在的类ζ(A)

the source code into tokens. Then we check each token to recognize the related method definitions. For each method j(a) (a [ A), we insert the code segment Log_Finishing_ Event depicted in Fig. 3 after the last statement of the method. This code segment is used to log the execution information about the method and its class.

### 3.3 Matching program execution traces with activity diagram behavior

By running the program under testing with randomly generated test cases, we obtain a set of program execution traces. For selecting the test cases according to a given test adequacy criterion, we need to match these program execution traces with the dynamic behaviors of an activity diagram.

大意：通过使用随机生成的测试用例运行被测试的程序，我们得到一组程序执行轨迹。为了根据给定的测试充分性标准选择测试用例，我们需要将这些程序执行跟踪与活动图的动态行为相匹配。

For a Java program, its execution traces we gather are a set of sequences of the method completion log items. These log items correspond to the activity state completions in a given activity diagram.

对于Java程序，我们收集的执行跟踪是一组方法完成日志项的序列。这些日志项对应于给定活动图中的活动状态完成。

### 3.4 Selecting test cases according to test adequacy criteria

After matching the program execution traces with the runs of a given activity diagram, we need to compute the contribution of the corresponding runs w.r.t. a given test adequacy criterion, and decide whether the corresponding test case should be selected.

大意：在将程序执行轨迹与给定的活动图的运行相匹配之后，我们需要根据给定的测试充分性标准计算相应运行的贡献，并决定是否应该选择相应的测试用例。

For the activity/transition coverage, the test case selection is simple. For each run which is consistent with a program execution trace, if it contains some activity states/transitions which are not covered previously, then the corresponding test case is picked out. The selection process terminates when the test adequacy criterion is satisfied, i.e. all activity states/transitions in the activity diagram are covered, or no more test cases can be picked out. In the later case we need to compute the coverage value, which is the ratio of the covered activity states/transitions to all activity states/transitions in the activity diagram.

大意：对于活动/转换覆盖，测试用例的选择是简单的。对于与程序执行跟踪一致的每一次运行，如果它包含一些之前没有覆盖的活动状态/转换，那么将挑选出相应的测试用例。当测试充分性标准得到满足时，选择过程终止，即活动图中的所有活动状态/转换都被覆盖了，或者没有更多的测试用例可以被挑选出来。在后一种情况中，我们需要计算覆盖率值，这是活动图中覆盖的活动状态/转换与所有活动状态/转换的比率。

The simple path coverage requires that all the simple paths in a given activity diagram be covered. It follows that we first need to find out all the simple paths in a given activity diagram. For an activity diagram D ¼ (A, T, F, aI, aF), we give an algorithm to generate all of its simple paths (cf. Fig. 5). The algorithm traverses the state space of D along with the concurrent transitions in a depth first manner starting from the initial state faIg. The path segment in the state space that we have so far traversed is stored in the list variable current_pathsegment, and the simple paths which are founded out are stored in the set variable simplepath_set. For each new state that we discover by firing a concurrent transition, we first check whether it is faFg. If yes, then we find out a simple path and put it into simplepath_set. Otherwise we check if the new state that we discover is such that current_runsegment can be extended further into a simple path. If yes, then we add the new state to current_pathsegment and start the search from it, otherwise we backtrack. Notice the above algorithm traverses the state space of an activity diagram along with the concurrent transitions so that it avoids the complexity caused by concurrency.

大意：简单路径覆盖要求覆盖给定活动图中的所有简单路径。因此，我们首先需要找出给定活动图中的所有简单路径。对于活动图D，我们给出了一个算法来生成它的所有简单路径(参见图5)。

In order to select test cases according to the simple path coverage, we need to check if a program execution trace covers a simple path.

大意：为了根据简单路径覆盖来选择测试用例，我们需要检查一个程序执行跟踪是否覆盖了一个简单路径。

For each program execution trace which is generated by running the program with the random test cases, we can decide if its corresponding test case should be picked out for the simple path coverage by checking if it covers a simple path which is not previously covered. The selection process terminates when all simple paths in the activity diagram are covered or no more test case can be picked out. In the later case, we need to compute the coverage value, which is the ratio of the covered simple paths to all simple paths in the activity diagram.

大意：对于使用随机测试用例运行程序所生成的每个程序执行轨迹，我们可以通过检查它是否覆盖了之前没有覆盖的简单路径，来决定是否应该为简单路径覆盖挑选相应的测试用例。当活动图中的所有简单路径都被覆盖，或者没有更多的测试用例被选中时，选择过程终止。在后一种情况中，我们需要计算覆盖值，即活动图中覆盖的简单路径与所有简单路径的比率。

The trail coverage requires that all the given trails in an activity diagram be covered. As the trails are introduced for specifying some special executions in a given activity diagram which should be covered in testing, they are usually singled out manually. In order to select test cases according to the trail coverage, we need to check if a program execution trace covers a trail.

大意：路径覆盖要求覆盖活动图中所有给定的路径。由于引入trail是为了在一个给定的活动图中指定一些在测试中应该涵盖的特殊执行，所以它们通常是手工挑选出来的。为了根据trail覆盖范围选择测试用例，我们需要检查一个程序执行轨迹是否覆盖了一个trail。

For example, for the trail t1→t4→t7 in the activity diagram depicted in Fig. 1, it is covered by a program execution trace
which is consistent with the run

![image-20210920185838148](https://raw.githubusercontent.com/SNIKCHS/MDImage/main/img/image-20210920185838148.png)

Given the trails in an activity diagram as a trail coverage criterion, for each program execution trace which is generated by running the program with the random test cases, we can decide if its corresponding test case should be picked out for the trail coverage by checking if it covers a trail which is not previously covered. The selection process terminates when all the given trails are covered or no more test case can be picked out. In the later case, we need to compute the coverage value, which is the ratio of the covered trails to all the given trails.

鉴于一个活动图路径轨迹覆盖准则,为每个项目执行跟踪是通过运行程序随机生成测试用例,我们可以决定是否相应的测试用例应该挑出跟踪报道通过检查如果它涵盖了一个小道,不是以前。当覆盖了所有给定的路径或者没有更多的测试用例时，选择过程终止。在后一种情况下，我们需要计算覆盖率值，即覆盖的路径与所有给定路径的比率。

### 3.5 Consistency checking

The algorithm described in Fig. 4 can also be used to check the consistency between the program execution traces and the behavior of activity diagrams. For a program under testing with an activity diagram as its design model, for a program execution trace v we gather, if there is no run in the activity diagram consistent with v, then an inconsistent case occurs. There are two causes for this inconsistent case: one is the program bugs resulting from the wrong temporal orders of method calls, the other is that the activity diagram is imperfect itself.

大意：图4中描述的算法还可以用来检查程序执行轨迹和活动图的行为之间的一致性。对于一个以活动图作为设计模型的测试程序，对于一个我们收集的程序执行轨迹v，如果在活动图中没有与v一致的运行，那么就会发生不一致的情况。这种不一致的情况有两个原因:一个是由于方法调用的时间顺序错误而导致的程序错误，另一个是活动图本身是不完美的。

Therefore, the approach presented above can also be used to detect not only the program bugs resulting from the wrong temporal orders of method calls, but also the imperfect activity diagram models constructed in reverse engineering for the legacy systems. Therefore, this approach also leads to a testing tool, which may proceed in a fully automatic fashion.

大意：因此，上面提出的方法不仅可以用来检测由于错误的方法调用时间顺序而导致的程序错误，还可以用来检测遗留系统的逆向工程中构建的不完善的活动图模型。因此，这种方法还会产生一个测试工具，它可以以完全自动化的方式进行。

### 3.6 Tool prototype and case study

We have implemented a tool prototype to support the approach presented in this paper. The tool has a graphical interface to allow users to construct, edit and analyze activity diagrams interactively. Its snapshot is shown in Fig. 6. The tool can instrument a Java program according to a given activity diagram, use the randomly generated test cases to run the instrumented program and gather the corresponding program execution traces. By comparing these traces with the behavior of the activity diagram, the tool can pick out test cases into a test suite according to a given test adequacy criterion, as well as evaluate to which extent the test suite satisfies the test adequacy criterion. The tool can also be used to check the consistency between the program execution traces and the behavior of activity diagrams.

大意：我们已经实现了一个工具原型来支持本文提出的方法。该工具有一个图形界面，允许用户交互式地构造、编辑和分析活动图。其快照如图6所示。该工具可以根据给定的活动图检测Java程序，使用随机生成的测试用例来运行检测的程序，并收集相应的程序执行轨迹。通过将这些轨迹与活动图的行为进行比较，工具可以根据给定的测试充分性标准将测试用例挑选到测试套件中，并评估测试套件满足测试充分性标准的程度。该工具还可以用来检查程序执行跟踪和活动图的行为之间的一致性。

By the tool, we have conducted several case studies for showing the potential and usability of the approach presented
in this paper. One case study is an on-line stock exchange system (OSES), which is reconstructed from an example in [13]. It is implemented in Java and contains 40 classes, 305 methods. The main purpose of OSES, which is modeled by an activity diagram depicted in Fig. 7, is to accept, check
and execute the customer’s orders. These features are implemented by Stock Broker and Securities Exchange. First, Stock Broker accepts a customer’s order, and checks it. If the customer’s account or the ordered stock does not exist, this order will be stopped. Otherwise, it will be submitted to Securities Exchange for further processing. Then, Securities Exchange executes the order in different ways according to its type and operation. Executing an order is a matching process, i.e. Securities Exchange searches appropriate orders in the database to make trade. For a market-order, Securities Exchange just finds the buy-order or sell-order and makes trade by the current stock price. For a limit-order, as it must be traded by the restricted or better price, Securities Exchange first checks the price set given by the customer. If the price is valid, Securities Exchange will find the buy-order or sell-order to make trade by the limited or better price. Otherwise, the order will not be traded and its result will be set ‘NO MATCH’. For any order, its executing result falls into four classes: ‘FAILURE’, ‘SUCCESS’, ‘PARTLY EXECUTION’ and ‘NO MATCH’. If the order is invalid, its result will be ‘FAILURE’. If the ordered stock is traded completely, partly or none, the result will be ‘SUCCESS’, ‘PARTLY EXECUTION’ or ‘NO MATCH’, respectively. After executing the order, Securities Exchange starts multiple threads to process the result concurrently, and exits at last.

大意：通过该工具，我们进行了几个案例研究.一个案例研究是一个在线证券交易系统(os)，它是由[13]中的一个例子重建的。它是用Java实现的，包含40个类，305个方法。由图7所示的活动图所建模的操作系统的主要目的是接受、检查并执行客户的订单。这些功能由股票经纪人和证券交易所实现。首先，股票经纪人接受客户的订单，并检查它。如果客户的帐户或订购的库存不存在，该订单将被停止。否则，将提交证券交易所进行进一步处理。然后，证券交易所根据其类型和操作以不同的方式执行该顺序。执行订单是一个匹配的过程，即证券交易所在数据库中搜索合适的订单进行交易。对于市场指令，证券交易所只需找到买入指令或卖出指令，并根据当前股票价格进行交易。对于限价订单，由于它必须以限价或更好的价格进行交易，证券交易所首先检查客户给出的价格。如果价格是有效的，证券交易所将找到买入或卖出订单，以有限或更好的价格进行交易。否则，该订单将不会被交易，其结果将被设置为“NO MATCH”。对于任何顺序，其执行结果可分为四个类:' FAILURE '， ' SUCCESS '， ' PARTLY EXECUTION '和' NO MATCH '。如果顺序无效，其结果将是' FAILURE '。如果订购的股票全部、部分或没有交易，结果将分别为“成功”、“部分执行”或“NO MATCH”。命令执行后，证券交易所启动多个线程并发处理结果，最后退出。

In the activity diagram depicted in Fig. 7, there are totally 25 activity states, 30 transitions and 18 simple paths. Each activity state in this diagram is labeled with a method in the program. The input of OSES is an order object, which consists of several member variables, such as the number of ordered stock, the ordered amount, the type of order (market-order or limit-order) and the operation of the order (buy-order or sell-order). Ordered price is required for limit-order. We can generate an order by randomly setting these variables.For the trail coverage criterion, we choose the following four trails as the special executions in the activity diagram which should be covered in testing.

大意：在图7所示的活动图中，总共有25个活动状态，30个转换和18个简单路径。这个图中的每个活动状态都用程序中的方法进行了标记。操作系统的输入是一个订单对象，它由多个成员变量组成，如订单数量、订单数量、订单类型(市场订单或限价订单)和订单操作(买入订单或卖出订单)。限价订货需注明订购价格。我们可以通过随机设置这些变量来生成一个顺序。对于轨迹覆盖标准，我们选择以下四个轨迹作为活动图中需要在测试中覆盖的特殊执行。

With the tool, we instrument the program, run it by generating 20, 50, 100, 300, 500 and 800 random orders, respectively, for OSES as inputs, gather the corresponding execution traces, and select the test cases into the test suite according to the four test adequacy criteria introduced in Section 3.1. The experimental results are shown in Table 1.

大意：使用该工具，我们测量程序，分别为操作系统生成20、50、100、300、500和800个随机订单作为输入来运行它，收集相应的执行轨迹，并根据3.1节中介绍的四个测试充分性标准选择测试用例到测试套件中。

With the tool, we also conduct the experiments on checking the consistency between the program execution traces and the
behavior of the activity diagram, and the tool comfortably finds out all the inconsistent cases which results from several related bugs embedded manually in the program or activity diagram.

大意：利用该工具，我们还进行了检查程序执行轨迹与程序执行轨迹之间的一致性的实验活动图的行为，并且该工具可以轻松地找出所有不一致的情况，这些情况是由程序或活动图中手工嵌入的几个相关错误导致的。

The other case studies we have conducted have approximately the same size as the OSES. Although we do not conduct any more case studies with larger size, we think there is no particular obstacle to implement the approach presented in this paper in a fully automatic fashion since the algorithms in the approach are simple and efficient.

大意：我们进行的其他案例研究的规模与OSES大致相同。虽然我们没有进行更多更大规模的案例研究，但我们认为，由于本文方法中的算法简单高效，所以完全自动化实现本文方法没有特别的障碍。

As in the approach we select the test cases from a set of randomly generated test cases, there is an important question in random testing, which is how many random test cases are sufficient? However this problem is not so concerned with us. That is because the goal of our approach is to automate the test case generation process so as to reduce the testing cost. Owing to the inexpensive charge, the tool can run as long as possible. We think the random test cases sufficient when the tool has been running long enough in our tolerable duration, or when an apparent and believable result can be concluded, i.e. the given test adequacy criteria are satisfied, or an inconsistent case is detected.

大意：在方法中，我们从一组随机生成的测试用例中选择测试用例，在随机测试中有一个重要的问题，那就是多少个随机测试用例是足够的?然而，这个问题与我们无关。这是因为我们方法的目标是自动化测试用例生成过程，从而降低测试成本。由于费用低廉，该工具可以尽可能长时间运行。我们认为，当工具在我们可容忍的持续时间内运行了足够长的时间，或者可以得出一个明显且可信的结果，即满足给定的测试充分性标准，或者检测到一个不一致的情况时，随机测试用例就足够了。

## 4. RELATED WORK

说一下其他学者的工作，自己的有什么不同

## 5. CONCLUSION

This paper propose an approach to automatic test case generation for Java programs with UML activity diagrams as design models. Guided by a given activity diagram, the program under testing is first instrumented so as to collect the related program execution traces. Then abundant test cases are randomly generated for driving the program. By running the instrumented program with these randomly generated test cases, we obtain the corresponding program execution traces. By matching those program execution traces with the behavior of the activity diagram, we select a reduced test suite according to the test adequacy criterions concerning the activity diagram. The approach can also be used to check the consistency between the program execution traces and the behavior of activity diagrams.

大意：本文提出了一种以UML活动图作为设计模型的Java程序测试用例自动生成方法。在给定活动图的指导下，首先对测试中的程序进行检测，以便收集相关的程序执行轨迹。然后随机生成大量的测试用例来驱动程序。通过使用这些随机生成的测试用例运行被测试的程序，我们获得了相应的程序执行轨迹。通过将那些程序执行轨迹与活动图的行为相匹配，我们根据有关活动图的测试充分性标准选择一个精简的测试套件。该方法还可以用来检查程序执行跟踪和活动图的行为之间的一致性。

The approach presented in this paper focuses on the test case generation for Java programs, but its underlying idea is more general and may also be applied to the test case generation for other object-oriented programs. The next work is to extend the approach to support the compositions of UML dynamic models as design specifications for test case generation.

大意：本文中提出的方法主要关注于Java程序的测试用例生成，但其底层思想更为通用，也可以应用于其他面向对象程序的测试用例生成。接下来的工作是扩展该方法，以支持UML动态模型的组合，作为测试用例生成的设计规范。







传统的活动图模型缺乏精确的语义，所以作者在这里进行活动图形式化定义

