# 1.进程与线程

## 进程的状态与转换

![image-20210824193759180](https://raw.githubusercontent.com/SNIKCHS/MDImage/main/img/image-20210824193759180.png)

## 进程控制

进程控制使用原语，有创建原语、撤销原语、阻塞原语与唤醒原语

## 进程的组织

1. 进程控制块PCB（核心）

   操作系统通过PCB表来管理和控制进程。

2. 程序段

3. 数据段

## 进程的通信

PV操作

1. 共享存储

   在通信的进程之间存在一块可直接访问的共享空间,通过对这片共享空间进行写/读操作实现进程之间的信息交换，在对共享空间进行写/读操作时，需要使用同步互斥工具(如Р操作、V操作)，对共享空间的写/读进行控制。

2. 消息传递

   在消息传递系统中，进程间的数据交换是以格式化的消息（Message）为单位的。若通信的进程之间不存在可直接访问的共半空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。

3. 管道通信

   所谓“管道"，是指用于连接一个进程读和一个进程写以实现它们之间的通信的-一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程)，以字符流形式将数据送入(写）管道;而接收管道输出的接收进程（即读进程）则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力:互斥、同步和确定对方的存在。管道通信是半双工通信

## 线程

引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

线程是基本的CPU执行单元，自己不拥有系统资源，共享所属进程的资源。进程是除CPU外系统资源的分配单元



### 线程与进程的比较

1. 线程是独立调度的基本单位，进程是拥有资源的基本单位。

2. 线程本身并不拥有系统资源，仅有一点必不可少的、能保证独立运行的资源。
   与该进程的其它线程共享该进程所拥有的资源

3. 创建或撤销进程开销大，线程开销小

   创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU环境的保存及新调度到进程CPU环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 同一进程内的多个线程共享进程的地址空间

# 2 处理机调度

## 进程调度方式

1. 非剥夺调度
2. 剥夺调度

## 典型调度算法

1. 先来先服务调度(FCFS)

   属于非剥夺调度

2. 短作业优先调度(SJF)

   导致饥饿现象

3. 优先级调度

4. 高相应比优先调度

5. 时间片轮转调度

6. 多级反馈队列调度

# 3 进程同步

1. 临界资源

   一次仅允许-一个进程使用的资源称为临界资源。对临界资源的访问必须互斥进行。

2. 同步

   进程因协调工作次序而等待。

3. 互斥

   进程因使用临界资源而等待。

## 信号量

### 记录型信号量

![image-20210613142946714](https://raw.githubusercontent.com/SNIKCHS/MDImage/main/img/20210613142946.png)

~~~c++
void wait (semaphore S){
    S.value--;
    if(S.value<0){
        add this process to S.L;
        block(S.L);
    }
}
~~~

~~~c++
void signal (semaphore S){
    S.value++;
    if(S.value<=0){
        remove a process P from S.L;
        wakeup(P);
    }
}
~~~

## 经典同步问题

### 生产者消费者问题

~~~c++
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;
producer(){
    while(1){
        produce an item in nextp;
        P(empty);
        P(mutex);
        add nextp to buffer;
        V(mutex);
        v(full);
    }
}
consumer(){
    while(1){
        P(full);
        P(mutex);
        remove an item from buffer;
        V(mutex);
        V(empty);
        consume the item;
    }
}
~~~

### 读者写者问题

~~~c++
int count = 0;
semaphore mutex = 1;
semaphore rw = 1;
writer(){
    while(1){
        P(rw);
        writing;
        V(rw);
    }
}
reader(){
    while(1){
        P(mutex);
        if(count==0)
            P(rw);
        count++;
        V(mutex);
        reading;
        P(mutex);
        count--;
        if(count==0)
            V(rw);
        V(mutex);
    }
}
~~~

写优先

~~~c++
int count = 0;
semaphore mutex = 1;
semaphore rw = 1;
semaphore w = 1;
writer(){
    while(1){
        P(w);
        P(rw);
        writing;
        V(rw);
        V(w);
    }
}
reader(){
    while(1){
        P(w);
        P(mutex);
        if(count==0)
            P(rw);
        count++;
        V(mutex);
        V(w);
        reading;
        P(mutex);
        count--;
        if(count==0)
            V(rw);
        V(mutex);
    }
}
~~~

### 哲学家进餐问题

~~~c++
semaphore chopstick[5] = {1,1,1,1,1};
semaphore mutex = 1;
Pi(){
    do{
        P(mutex);
        P(chopstick[i]);
        P(chopstick[(i+1)%5]);
        V(mutex);
        eat;
        V(chopstick[i]);
        V(chopstick[(i+1)%5]);
        think;
    }while(1);
}
~~~

# 4 死锁

死锁产生的必要条件

- 互斥条件
- 不剥夺条件
- 请求并保持条件
- 循环等待条件

## 死锁预防

1. 破坏互斥条件

   允许系统资源都能共享使用

2. 破坏不剥夺条件

   当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。

3. 破坏请求并保持条件

   采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。

4. 破坏循环等待条件

   为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。

## 死锁避免

### 银行家算法

当一个进程申请使用资源的时候，银行家算法通过先 **试探** 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。

而安全性算法是指剩余资源够不够满足进程队列的某个进程，而在这个进程结束后加上该进程的资源能否满足进程队列剩下的某个进程，以此类推直到队列所有进程都可满足就是安全的