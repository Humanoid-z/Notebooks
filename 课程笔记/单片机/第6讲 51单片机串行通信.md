# 计算机通信的基本概念

通信有==并行通信==和==串行通信==两种方式

并行通信的传输速率一般较串行通信更快

串行通信是将数据字节的8位分成一位一位的形式在一条传输线上逐个地传送
==串行通信的特点==：传输线少，长距离传送时成本低，且可以利用电话网等现成的设备，但数据的传送控制比并行通信复杂

**串行通信的传输方向**

单工
	单工是指数据传输仅能沿一个方向，不能实现反向传输
半双工
	半双工是指数据传输可以沿两个方向，但需要==分时==进行
全双工
	全双工是指数据可以同时进行双向传输

**串行通信的错误校验**

==奇偶校验==

- 在发送数据时，数据位尾随的1位为奇偶校验位（1或0）
- 奇校验时，数据中“1”的个数与校验位“1”的个数之和应为奇数
- 偶校验时，数据中“1”的个数与校验位“1”的个数之和应为偶数
- 接收字符时，对“1”的个数进行校验，若发现不一致，则说明传输数据过程中出现了差错

代码和校验

​	代码和校验是发送方将所发数据块求和（或各字节异或），产生一个字节的校验字符（校验和）附加到数据块末尾
​	接收方接收数据同时对数据块（除校验字节外）求和（或各字节异或），将所得的结果与发送方的“校验和”进行比较，相符则无差错，否则即认为传送过程中出现了差错

循环冗余校验
	这种校验是通过某种数学运算实现有效信息与校验位之间的循环校验，常用于对磁盘信息的传输、存储区的完整性校验等
	这种校验方法纠错能力强，广泛应用于同步通信中

**并行通信**通常是将数据字节的各位用多条数据线同时进行传送
==并行通信的特点==：控制简单、传输速度快；由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难

**异步通信**是指通信的发送与接收设备使用各自的时钟控制数据的发送和接收过程
为使双方的收发协调，要求发送和接收设备的时钟尽可能一致

异步通信是以字符（构成的帧）为单位进行传输，字符与字符之间的间隙（时间间隔）是任意的，但每个字符中的各位是以固定的时间传送的，即字符之间不一定有“位间隔”的整数倍的关系，但同一字符内的各位之间的距离均为“位间隔”的整数倍

**异步通信的特点**：不要求收发双方时钟的严格一致，实现容易，设备开销较小，但每个字符要附加2～3位用于起止位，各帧之间还有间隔，因此传输效率不高

异步通信的数据格式 如下：

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024131120339.png" alt="image-20201024131120339" style="zoom:80%;" />

**同步通信**时要建立发送方时钟对接收方时钟的直接控制，使双方达到完全同步。此时，传输数据的位之间的距离均为“位间隔”的整数倍，同时传送的字符间不留间隙，即保持位同步关系，也保持字符同步关系
发送方对接收方的同步可以通过以下两种方法实现

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024131150590.png" alt="image-20201024131150590" style="zoom:80%;" />

当单片机工作于异步通信时，由于异步传输每一次只传输1个字节的数据，所以衡量串行口传输速度的方法就是看它每秒传输多少个字节的数据
例如：串行口1秒传输1024个字节，则数据传输率为1024Bps，即1KBps。单位Bps代表“字节/秒”（Bytes per second）
更小的单位的是bps，即“位/秒”（bits per second）

除了以上两个单位外，另一个广泛使用的描述数据传输率的物理量是波特率，对应的单位为波特（baud）
==波特的定义是：传输数据中每秒信号的变化量。==通常把波特与位/秒看成相等，即1波特（Bd）等于1位/秒（bps）：
				1Bd=1bps
51单片机的**通用异步收发传输器**（UART）在传输数据时，可被设置不同的波特率，以达到不同的传输速率

# 51单片机串行口结构与组成

有两个物理上独立的接收、发送缓冲器SBUF，但它们占用同一地址99H 
接收器是双缓冲结构；发送缓冲器，因为发送时CPU是主动的，不会产生重叠错误

串行口缓冲寄存器SBUF是一个1个字节长度的寄存器，属于特殊功能寄存器
在发送数据时，当设置好串行口工作模式和波特率后，只要把数据载入SBUF中，串行口就会自动将数据发送出去
类似地，在接收数据时，串行口接收下来的数据保存在SBUF中以供程序读取

# 51单片机串行通信特殊功能寄存器功能

**串行口控制寄存器SCON**

串行口控制寄存器SCON是一个1个字节长度的特殊功能寄存器SFR
SCON控制着单片机串行通信的工作模式，可以被位寻址

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024131746354.png" alt="image-20201024131746354" style="zoom:80%;" />

SM0和SM1为工作方式选择位，可选择四种工作方式： 

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024131823196.png" alt="image-20201024131823196" style="zoom:80%;" />

![image-20201028110638571](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028110638571.png)

## SM2多机通信控制位(重要)

==SM2多机通信控制位==，一般用于使能或屏蔽多个单片机之间通信的功能。**主要用于方式2和方式3**
当接收机的==SM2=1==时可以利用收到的RB8来控制是否激活RI（RB8＝0时不激活RI，收到的信息丢弃；RB8＝1时收到的数据进入SBUF，并激活RI，进而在中断服务中将数据从SBUF读走）来区分地址帧和数据帧
当==SM2=0==时，不论收到的RB8为0和1，均可以使收到的数据进入SBUF，并激活RI（即此时RB8不具有控制RI激活的功能）。通过控制SM2，可以实现多机通信中的奇偶校验
**在方式0时，SM2必须是0。**在方式1时，若SM2=1，则只有接收到有效停止位时，RI才置1

当SM2=1时

- RB8=1时激活RI （地址帧到来），每个从机都要接收
- RB8=0时不激活RI丢弃数据 （数据帧到来）未被选中的从机丢弃数据

当SM2=0时

- RB8与RI的激活没关系 变为双机通信时的奇偶校验位
- 有数据接收到就激活RI

只有方式2和3可用于多机通信，注意SM0与SM1的取值
3个**从机**设置SM2=1，RB8＝1为接收地址帧数据
当**主机发送地址**address给三个从机时，主机的TB8置1，每个从机都接收RB8为1且置位各自的RI，然后在中断服务子程序中接收并对比自己的address，被选中的从机修改SM2=0进入数据接收，而未被选中的从机依旧链接到主机的TXD端口
当**主机发送数据**时，主机的TB8置0，被选中的从机由于SM2=0，接收到数据就激活RI可顺利接收数据，而未被选中的从机由于RB8=0而丢弃了被动接收到的不属于自己的数据

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024132355907.png" alt="image-20201024132355907" style="zoom:80%;" />

==REN==位为接收使能位，当REN=1时，单片机可以从串行口接收数据。如果REN=0，则接收功能被禁止
==TI==位与==RI==位是串行通信的重要标志位
当单片机完成SBUF中的数据发送后，发送中断标志位TI被硬件置1，以利于程序判断数据发送的完成情况
当单片机接收数据完毕后，接收中断标志位RI会硬件置1，可用于判断数据接收是否完成

==TB8==，在方式2或方式3中，是==发送数据的第九位==，可以用软件规定其作用。可以用作数据的奇偶校验位，或在多机通信中，作为地址帧/数据帧的标志位。注意：在方式0和方式1中，该位未用
==RB8==，在方式2或方式3中，是==接收到数据的第九位==，作为奇偶校验位或地址帧/数据帧的标志位。在方式1时，若SM2=0，则RB8是接收到的停止位

TI，发送中断标志位。在方式0时，当串行发送第8位数据结束时，或在其它方式，串行发送停止位的开始时，由内部硬件使TI置1，向CPU发中断申请。在中断服务程序中，必须用软件将其清0，取消此中断申请
RI，接收中断标志位。在方式0时，当串行接收第8位数据结束时，或在其它方式，串行接收停止位的中间时，由内部硬件使RI置1，向CPU发中断申请。也必须在中断服务程序中，用软件将其清0，取消此中断申请

## 电源控制寄存器PCON

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024132820655.png" alt="image-20201024132820655" style="zoom:80%;" />

==SMOD（PCON.7）波特率倍增位==。在串行口方式1、方式2、方式3时，波特率与SMOD有关，当SMOD=1时，波特率提高一倍。上电复位时，SMOD=0

GF1，GF0：两个通用工作标志位，用户可以自由使用
PD：掉电模式设定位
PD=0 单片机处于正常工作状态
PD=1 单片机进入掉电（Power Down）模式，可由外部中断或硬件复位模式唤醒，进入掉电模式后，外部晶振停振，CPU、定时器、串行口全部停止工作，只有外部中断工作
IDL：空闲模式设定位
IDL=0 单片机处于正常工作状态
IDL=1 单片机进入空闲（Idle）模式，除CPU不工作外，其余仍继续工作，在空闲模式下可由任一个中断或硬件复位唤醒

一个机器周期是12个时钟周期，所以用12MHz时，一个机器周期是1微秒，好计算且速度相对是最高的
但进行通信时，一般选择11.0592MHz，12MHz频率进行串行通信不容易实现标准的波特率，比如9600，4800，而11.0592M计算时正好可以得到，因此在有通信接口的单片机中常用11.0592M

# 51单片机串行口四种工作方式及波特率计算方法

## 单片机串行口工作方式0 

==串行口方式0是扩展移位寄存器方式==，串行口为同步移位寄存器的输入/输出方式，该模式下只发送或接收8位数据
方式0主要用于扩展并行输入或输出口。数据由RXD（P3.0/10管脚）引脚输入或输出，同步移位脉冲由TXD（P3.1/11管脚）引脚输出。发送和接收均为8位数据，低位在先，高位在后
方式0下串行口控制寄存器SCON的SM2位应设为0，且TB8位无用
==波特率固定为fosc/12==

输出（发送），首先通过指令“MOV  SCON,  #00H”设置串行口工作在模式0下发送数据
将要发送的8位数据载入串行口缓冲寄存器SBUF，串行口就会自动将SBUF中的数据转换成8位串行数据，并以固定的波特率从RXD端发送出去
当数据发送完成后，SCON中的标志位TI会被硬件置1。这时，可用指令“JBC  TI, CHECK”来检测TI位并将其清0

输入（接收），首先通过指令“MOV  SCON,  #10H”设置串行口工作在模式0下接收数据（RI位=0、REN位=1）
串行口随即启动接收，此时RXD端为数据接收端，TXD端仍然为移位脉冲输出。当1个字节的数据接收完毕后保存在SBUF中，同时标志位RI被置1，可用指令“JBC  RI, LOOP”来检测RI位并清0

## 单片机串行口工作方式1

==方式1是10位数据的异步通信口==，TXD为数据发送引脚，RXD为数据接收引脚，传送一帧数据的格式:1位起始位，8位数据位，1位停止位

方式1下串行通信的波特率是可变的，由Timer 1工作在模式2下，通过载入Timer寄存器TH1和TL1的计数初始值来设置波特率。在模式2下，单片机会自动根据Timer 1的计数初始值得出波特率。计算公式如下：<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024134051539.png" alt="image-20201024134051539" style="zoom:67%;" />

上式中TH1是Timer 1寄存器，SMOD1是电源控制寄存器PCON中的位7，如果SMOD1=0为单倍波特率，如果SMOD1=1则为双倍波特率

例题：假设使用单倍波特率，即SMOD1=0，单片机晶振频率fc = 11.0592MHz，向Timer 1寄存器TH1（=TL1）中载入F3H，即TH1=243，根据计算公式得波特率：

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024134143451.png" alt="image-20201024134143451" style="zoom:67%;" />

<font size=5>($\frac{11.0592*10^6}{32*16*12}=1800$)</font>

REN为1时，接收器以所选择波特率的16倍速率采样RXD引脚电平，检测到RXD引脚输入电平发生负跳变时，则说明起始位有效，将其移入输入移位寄存器，并开始接收这一帧信息的其余位。接收过程中，数据从输入移位寄存器右边移入，起始位移至输入移位寄存器最左边时，控制电路进行最后一次移位
当RI=0，且SM2=0（或接收到的停止位为1）时，将接收到的9位数据的前8位数据装入接收SBUF，第9位（停止位）进入RB8，并置RI=1，向CPU请求中断

## 单片机串行口工作方式2、3

==串行口工作方式2或方式3时为11位数据的异步通信口==。模式3与模式2的串行口功能、发送/接收过程几乎相同，只是模式3的波特率可控，TXD为数据发送引脚，RXD为数据接收引脚 

方式2和方式3时起始位1位，数据9位（含1位附加的第9位，发送时为SCON中的TB8，接收时为RB8），停止位1位，一帧数据为11位
方式2的波特率固定为晶振频率的1/64或1/32，方式3的波特率由定时器T1的溢出率决定

输出（发送）开始时，先把起始位0输出到TXD引脚，然后发送移位寄存器的输出位（D0）到TXD引脚。每一个移位脉冲都使输出移位寄存器的各位右移一位，并由TXD引脚输出
第一次移位时，停止位“1”移入输出移位寄存器的第9位上，以后每次移位，左边都移入0。当停止位移至输出位时，左边其余位全为0，检测电路检测到这一条件时，使控制电路进行最后一次移位，并置TI=1，向CPU请求中断

输入（接收）时，数据从右边移入输入移位寄存器，在起始位0移到最左边时，控制电路进行最后一次移位
当RI=0，且SM2=0（或接收到的第9位数据为1）时，接收到的数据装入接收缓冲器SBUF和RB8（接收数据的第9位），置RI=1，向CPU请求中断。如果条件不满足，则数据丢失，且不置位RI，继续搜索RXD引脚的负跳变

方式2的波特率固定为晶振频率的1/64或1/32![image-20201115161211271](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201115161211271.png)，方式3的波特率由定时器T1的溢出率决定，计算公式为：<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024134051539.png" alt="image-20201024134051539" style="zoom:67%;" />
方式2下发送数据时，数据由TXD端送出，数据中的第9位数据从串行口控制寄存器SCON中的TB8位取得（可用指令“MOV  TB8, bit”向TB8位载入数据bit）
与其他模式相同，向SBUF载入数据后即自动发送。发送完一帧数据后，发送中断标志位TI=1，所以可用指令“JBC  TI, CHECK”来检测TI并将其清0

方式2下接收数据时，需要将串行口控制寄存器SCON中的REN位置1，串行口就会启动接收过程。RXD端接收，数据中的第9位载入SCON寄存器的RB8位上。接收完1帧数据后，RI位被置1，可用指令“JB  RI, CHECK”来检测RI位以判断接收完成情况

## 波特率的计算

    方式0的波特率 =  fosc/12
    方式2的波特率 =（2^SMOD/64）· fosc 
    方式1或3的波特率 =（2^SMOD/32）·（T1溢出率）
当T1作为波特率发生器时，最典型用法是使T1工作在自动再装入的8位定时器方式（即模式2，且TCON的TR1=1，以启动定时器），此时T1溢出率取决于TH1中的计数初值X，初值计算如下：

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024135716352.png" alt="image-20201024135716352" style="zoom:67%;" />

根据串行通信方式1、3的波特率计算公式： 2SMOD× T1溢出率/32

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024135733732.png" alt="image-20201024135733732" style="zoom:67%;" />

例题：已知fosc=11.0592MHz，T1工作在模式2作波特率发生器，波特率=2400b/s，计算SMOD=0 时T1的初值

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201024135746282.png" alt="image-20201024135746282" style="zoom:67%;" />

![image-20201028110853868](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028110853868.png)

## 串口初始化

 串行口工作之前，应对其进行初始化，主要是设置产生波特率的定时器1、串行口控制和中断控制。具体步骤如下：
确定T1的工作方式（编程设置TMOD寄存器）
计算T1的初值，装载TH1、TL1
启动T1（TCON中的TR1位）
确定串行口控制（编程设置SCON寄存器）
串行口在中断方式工作时，要进行中断设置（编程设置IE、IP寄存器）

# 单片机串行通信应用

![image-20201028110910881](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028110910881.png)

![image-20201028110917595](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028110917595.png)

例1：根据下图编写汇编程序，当开关K合上时, 采集8位开关量，根据开关的不同状态进行不同处理。

![image-20201028110940989](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028110940989.png)

例1汇编程序如下: 
    START:  JB  P1.0,   \$      ; 开关K未合上, 等待
                  CLR  P1.1         ; 74LS165并行输入数据
                  SETB  P1.1       ; 开始串行移位
                  MOV  SCON,  #10H   ; 串行口方式 0并启动接收
                  JNB  RI, $         
                  CLR  RI
                  MOV  A,  SBUF  ; 输入数据
                           ……             ; 根据  A处理不同任务
                  SJMP  START      ; 准备下一次接收

例3：用查询方式编写双机通信程序，实现：
           甲机：将片内RAM40H～4FH的16B数据发送给乙机
           乙机：接收甲机发送的数据
           同时具有奇偶校验功能

![image-20201028111026716](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028111026716.png)

甲机发送（采用查询方式）
MOV  SCON,  #80H   ; 设置工作方式2
            MOV  PCON,  # 00; 置SMOD=0, 波特率不加倍
            MOV  R0,  # 40H ; 数据区地址指针
            MOV  R2,  # 10H ; 数据长度
LOOP: MOV  A,   @R0  ; 取发送数据
            MOV  C, P           ; 形成奇偶位送TB8
            MOV  TB8, C
            MOV  SBUF, A ; 送串口并开始发送数据
WAIT:  JBC TI,  NEXT  ; 检测是否发送结束并清TI
             SJMP  WAIT
NEXT: INC  R0        
             DJNZ R2,  LOOP
             RETI

乙机接收（查询方式）
            MOV  SCON,  # 90H  ; 方式2, 允许接收
          MOV  PCON,  #  00H  ; 置SMOD=0
            MOV  R0,  # 60H      ; 置数据区地址指针
            MOV  R2,  # 10H      ; 数据块长度
LOOP: JBC  RI,   READ   ; 等待接收数据并清RI
             SJMP LOOP
READ: MOV  A, SBUF      ; 读一帧数据
            MOV  C, P
            JNC  LP0                ;C为0跳转，即实际接收数据的奇偶校验位P为0跳转
            JNB  RB8,      ERR ; C为1则不跳转，即实际接收数据的奇偶校验位P为1，
                                             若RB8奇偶校验位为0，则出错跳转至ERR
            AJMP LP1
   LP0:  JB  RB8, ERR         ;P=0，RB8奇偶校验位为1则表明出错进行跳转到错误处理
   LP1:  MOV @R0, A        ; 无错， 接收一帧数据
 INC R0
 DJNZ R2, LOOP
 RETI
ERR:           ……             ; 出错处理程序

![image-20201028111122187](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028111122187.png)

![image-20201028111130766](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028111130766.png)

网络密码锁：用户在小键盘上输入密码，单片机扫描键盘获得密码（数字）并存储在30H中。单片机将保存在30H中的输入密码通过串行口发送到计算机端
计算机串行口接收到密码后，与预先设置好的有效密码进行比对，判断输入密码的正确性。如果密码正确，计算机将通过串行口向单片机回送数据11H，错误则回送88H
密码锁如果从串行口接收到11H则驱动门锁控制器打开锁，如果接收到88H则发出错误密码的警告

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第6讲 51单片机串行通信.assets\image-20201028111145760.png" alt="image-20201028111145760" style="zoom:150%;" />

# 本讲重点：

计算机通信的基本概念
串行通信接口结构与组成
串行口缓冲寄存器SBUF 、控制寄存器SCON、电源控制寄存器PCON的定义与功能
串行通信方式0、方式1、方式2、方式3的工作原理和波特率计算方法等
单片机与计算机、单片机双机与多机通信原理与过程