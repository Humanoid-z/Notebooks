# 单片机编程语言概述

汇编语言 

- **优点**是产生的目标代码短，占用的存储空间小，执行速度快，能充分发挥单片机的硬件功能。
- **缺点**是对于复杂的应用来讲使用汇编语言编程复杂，程序的可读性和可移植性不强

**如何来确定所需的编程语言？**

- 如果应用系统的存储空间比较小，且对实时性的要求很高，则应选用汇编语言
- 如果系统的存储空间比较大，且对实时性的要求不是很高，则应选用C51语言
- 如果系统中有部分模块对实时性的要求很高，而其它模块对实时性的要求不是很高，则可以将两种语言结合，程序的主体部分使用C51编程，对实时性要求高的模块用汇编语言编程，然后将汇编语言程序模块嵌入到C51语言程序当中



# C51扩展字、数据类型、存储类型

![image-20201024190523184](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第7讲 C51语言编程.assets\image-20201024190523184.png)

![image-20201024190726019](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第7讲 C51语言编程.assets\image-20201024190726019.png)

C51中有几种ANSI C所没有的特殊数据类型，这些数据类型与存储区域和存储器类型的概念密切相关
	位变量
	可位寻址的对象
	特殊功能寄存器

![image-20201024190830064](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第7讲 C51语言编程.assets\image-20201024190830064.png)

例：sfr   SCON = 0X98;
         sfr16    T2 = 0xCCBB;
         sbit      OV = PSW^4;

在C51中变量定义的格式如下：

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第7讲 C51语言编程.assets\image-20201024190945147.png" alt="image-20201024190945147" style="zoom:67%;" />

存储种类（Storage Classes）有四种：
	自动（auto）
	外部（extern）
	静态（static）
	寄存器（register）
如果省略存储种类，则该变量将默认为自动（auto）

auto类型：
在定义它的==函数体内部有效==
进入定义它的==函数体时动态分配内存==，退出函数体时所占用的内存区域被释放（局部变量）
变量的默认存储种类

register类型：
作用域与寿命和auto型相同
编译器尽可能将==该类变量放在CPU的寄存器中==，以提高存储速度
通常选择访问频率较高的变量定义为该类型，以提高效率

extern类型
在一个应用的==多个程序文件中均有效==
存放在内存的==静态存储区==
直到该程序结束，分配的内存才被释放（全局变量）

static类型
局部变量
	作用域与auto类型相同，寿命与extern类型相同
	数据值在两次调用之间一直保持，内存空间在程序结束才释放
全局变量
	仅在定义它的==程序文件内有效，寿命与extern类相同==
	作用范围受限的全局变量，仅在定义它的文件中有效

8051系列微处理器采用了==程序存储器和数据存储器分离==的哈佛结构。有三种不同类型的存储区域：
程序存储区（Program memory）
内部数据存储区（Internal data memory）
外部数据存储区（External data memory）
这三种存储区域通过==采用不同的指令和寻址方式来解决地址重叠的问题==

## C51的存储器类型修饰符

![image-20201024191430422](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第7讲 C51语言编程.assets\image-20201024191430422.png)

C51的带存储类型的变量声明举例

char data var1;		
char code text[] = "ENTER PARAMETER:"; 
unsigned long xdata array[100]; 
float idata x,y,z;	
unsigned int pdata dimension;	
unsigned char xdata vector[10][4][4];	
char bdata flags; 

## C51的存储模式

如果在变量声明时未声明变量的存储器类型，则该变量的存储器类型，由程序的存储模式来决定

- 小模式（Small model）：默认data区，缺省模式
- 紧凑模式（Compact model）：默认pdata区
- 大模式（Large model）：默认xdata区

注意：除非应用在特殊的场合，否则SMALL存储模式可以提供最快和最有效的代码

## 位变量

位变量（Bit Types）是指用一个二进制位表示的变量。位数据类型可以用来说明变量，参数表，函数返回值等。位数据变量声明和基本的数据类型声明一样
所有的位变量都存储在内部数据区的可位寻址段（**0x20～0x2F**）中。因为该段只有16个字节长，所以在一个作用域内最多只能声明128个位变量

例子：static  bit  done_flag = 0;	 // 位变量
             bit   testfunc (bit flag1, bit flag2 ) //参数和返回值均为位类型
             {
	      …
	      return (0); 	//位类型返回值 
              }

==位变量禁忌==

- 禁止中断的函数（#pragma disable）和显式定义寄存器组的函数( using  n )不能返回位变量

- 不能声明位类型指针

​		bit      *ptr; 		/*非法语句 */*

- 不能声明位类型的数组

  ​	bit       ware [5];	 /*非法语句*/

# C51位寻址、特殊功能寄存器

可位寻址的对象（Bit-addressable Objects）是指既可以字节（字）寻址也可以位寻址的对象
只有当数据对象占据51单片机内部数据区的可位寻址区时，才是一个可位寻址对象。C51使用bdata存储器类型来声明可位寻址对象
     例如：
int  bdata  ibase;	/*可位寻址的整型变量 */
Char  bdata  bary [4]; 	/* 可位寻址的字符型数组 */
注意：1.==可位寻址的对象必须为全局变量，不能是局部变量==。2.由于bdata区为16个字节，因此可寻址对象所占存储空间不能大于16个字节

可位寻址的对象的位可以单独访问和更改。可以用sbit声明位变量来访问bdata声明的变量的指定位。如：
sbit   mybit0 = ibase ^ 0; 		/* bit 0 of ibase */
sbit   mybit15 = ibase ^ 15; 		/ * bit 15 of ibase */
sbit   ary07 = bary[0] ^ 7; 		/* bit 7 of bary[0] */
sbit   ary37 = bary[3] ^ 7; 		/* bit 7 of bary[3] */
’^’后的表达式定义了位的位置，必须是一个常量。取值范围由基变量的数据类型来决定
对char和unsigned char 类型，常量范围为0-7个，注意不是取值范围！
对int, unsigned int, short, unsigned short，常量范围为0-15个
对long 和unsigned long ，常量范围为0-31个

位变量用基地址加位偏移来获取实际物理地址
位地址0指向第一个字节的第0位
8指向第2个字节的0位
8051中整型变量存储时是**高字节在低地址（第1个字节），低字节在高地址**（第2个字节）。即==整型的第0位在第2个字节的0位上，这个地址用sbit来标识时是位置8==

![image-20201026155633930](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第7讲 C51语言编程.assets\image-20201026155633930.png)

程序段阅读： 
int  bdata iData;  	//位寻址变量必须为全局变量
sbit  bTest1=iData^8;
sbit  bTest2=iData^0;
main()
{
		iData=0;
		bTest1=1;	//iData=1;
		iData=0;
		bTest2=1;	//iData=256;
}

![image-20201026155705465](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第7讲 C51语言编程.assets\image-20201026155705465.png)

## C51的特殊功能寄存器

C51系列的单片机提供了一个独立的内存区，用来存放特殊功能寄存器
SFR用来在程序中控制定时器，计数器，串行I/O，端口I/O操作，以及外设的操作。SFR驻留在地址**0x80**到**0xFF**空间，可按字节寻址或按字寻址，**某些寄存器还可以按位寻址**
C51系列单片机中SFR的个数和类型是变化的。C51没有预先定义SFR的名字，而是提供了许多8051兼容芯片的包含文件，这些文件对芯片的SFR进行了定义。C51编译器用sfr，sfr16，sbit对SFR进行定义
#include “cc2430.h”

常用有：
       reg51.h   reg52.h（定义特殊功能寄存器和位寄存器）
       math.h （定义常用数学运算）

**sfr：定义8位特殊功能寄存器**
SFR的声明和C变量的声明格式一样，只不过使用的修饰符不是char 或int 而是sfr
P0，P1，P2，P3是sfr声明的特殊功能寄存器的名称。特殊功能寄存器名称是一个合法的C标识符。**等号后的地址必须是数值常量，不允许使用带运算符的表达式**（判断）

**sfr16：定义16位特殊功能寄存器**
8051可以将两个8位SFR作为一个16位SFR访问。条件是两个SFR必须地址相邻，并且低字节地址在高字节地址的前面
sfr16用来进行16位的声明，声明时使用低字节地址作为sfr16的地址

**sbit：定义特殊功能位**
sbit访问SFR中的可寻址位和其它可位寻址对象的可寻址位
在C51应用中，经常需要对SFR中的可寻址位（特殊功能位）进行独立访问。可以用sbit数据类型来将SFR中的可寻址位声明为特殊功能位
例如：sbit EA = 0xAF;
上例中将EA定义为位地址0xAF，对C51而言这是中断使能寄存器（IE）的中断许可位

位地址声明的三种方法：

方法一： sfr_name ^ int_constant，如：
	sfr PSW = 0xD0;		//先声明寄存器名sfr_name
	sfr IE = 0xA8;
	sbit OV = PSW^2;	//后声明特殊功能位
	sbit CY = PSW^7;
	sbit EA = IE^7;
方法二： int_constant^int_constant，如：
	sbit OV = 0xD0^2;
	sbit CY = 0xD0^7;
	sbit EA = 0xA8^7;
方法三：int_constant，SFR地址加位数，如：
	sbit OV = 0xD2;
	sbit CY = 0xD7;
	sbit EA = 0xAF;

sbit、bit和位域区别

| **类型** | **访问对象**                                                 |
| -------- | ------------------------------------------------------------ |
| **sbit** | 可位寻址的变量（在bdata中声明的变量）或可位寻址的特殊功能寄存器SFR中的**位的声明** |
| **bit**  | 可位寻址区中的位（直接声明），共128位                        |
| **位域** | 将字节，整型，长整型的某几个位作为一个数据存储单元，进行独立访问 |

注意：使用sbit声明时，基对象必须可位寻址变量或者是可以位寻址的特殊功能寄存器

C51的绝对变量地址

开发者有时候希望把变量存储在指定的地址单元中。可用 \_at_ 关键词来将变量定位在一个绝对的内存地址单元。方法如下：
	数据类型  存储器类型   变量名  _at_  变量所在绝对地址
在_at_ 后面的绝对地址必须符合存储器类型的物理边界限制，即不超过存储区域的最大可寻址范围，且必须为常数
绝对变量定位遵循以下约束：

- 绝对变量不能初始化
- 类型为bit的函数和变量不能用绝对地址定位
- 绝对变量必须是全局变量，不能是局部变量

C51的绝对变量地址举例

struct   link
{
		struct   link   idata   *next;
		char              code     *test;
};

struct  link  idata   list  \_at_  0x40; 	/* list at idata 0x40 */
char   xdata   text[256]   \_at_  0xE000;     /* array at xdata 0xE000 */
int   xdata      i1    \_at_  0x8000; 	/* i1 at xdata 0x8000 */

void main ( void ) 
{
			list.next = (void *) 0;
			i1 = 0x1234;
			text [0] = 'a';
};

# C51数组和指针

C51的指针和标准C中的指针功能相同，但是由于8051体系结构的特殊性，C51提供了两种不同类型的指针：
**通用指针**（Generic Pointers）
**具体指针**（Memory-specific Pointers）
通用指针与标准C中的指针声明是相同的，不用指出指向数据的存储器类型。例如：
char  \*s; 		/* 指向字符类型的指针 */
int  \*numptr; 	/* 指向整型类型的指针*/
long  \*state;	             /* 指向长整型类型的指针 */

通用指针总是占用三个字节：
第1个字节保存指向变量的**存储器类型**编码值
第2个字节保存地址的高字节
第3个字节保存地址的低字节

具体指针是在声明时就指定了所指向的**存储器类型**的指针，是指向特定存储区域的指针变量
具体指针不需要保存存储器类型字节。因此具体指针比通用指针少1个字节，可以保存在1个字节（idata, data, bdata, pdata类型指针）或2个字节（code 和xdata类型指针）中
具体指针可以用来访问8051声明的存储区内的变量。具体指针的效率高，但灵活性较差

具体指针本身存储类型的定义

==‘\*’前==的存储器类型修饰指针指向的==数据==，==‘*’后==的存储器类型修饰==指针本身==，即指针所占据的存储区域类型
完成相同的功能，使用通用指针比具体指针要慢很多
原因：通用指针只有在程序运行时才能知道实际的变量存储区类型，因此编译器就不能对内存访问进行优化，从而只能生成可以访问任意存储区的通用代码

char data * xdata ptr; 	    /*ptr在xdata但指向data区的变量*/
int xdata * data numtab;        /*numtab在data区但指向xdata区变量 */
long code * idata powtab; 	   /*powtab在idata区但指向code区变量*/

指针变量的引用 

C语言中有两个与指针相关的运算符：
*：通过指针变量间接访问它所指向的变量
&：取地址运算符，取变量占用存储单元的首地址，即指针
数组元素的引用：
下标法（即[  ]运算符和对应元素的下标）
指针法（即通过指向数组元素的指针找到所需元素）

# C51函数

C51函数定义的格式：

函数类型  函数名(形式参数列表) [reentrant]  [interrupt n]  [using n]

静态函数（内部函数）

静态函数只能在定义它的文件中被调用，而不能被在其他文件中的函数所调用。定义格式为：

static 类型说明符 函数名（形式参数列表）

外部函数（默认）

外部函数可以在定义它的文件和其它文件中被调用。函数定义和调用时使用extern说明。默认所以关键字extern可省略

extern 类型说明符 函数名（形式参数列表）

可使用using规定函数使用的寄存器组。格式：
	函数类型   函数名(形式参数列表)    using  n 
	n=0~3，表示使用的寄存器组的编号
	using只能在函数定义中使用，不能在函数原型声明中使用
使用using属性的函数将自动完成以下操作： 
	进入函数前，将当前使用的寄存器组的标号保存在堆栈中
	更改PSW的寄存器组选择位（RS1、RS0），选择设定的寄存器组作为当前	的寄存器组
	函数退出时，将寄存器组恢复成进入函数前的寄存器组

规定函数使用的寄存器组举例

		int       alarm;
		int       alarm_count;
		extern     void  alfunc( int iValue );
	    void   falarm( void )   using  3   
	    {						                       				
	    alarm_count++;
	    	alfunc (alarm = 1);
	    }
## C51的中断函数

C51最大支持32个中断。中断函数的定义：
	函数类型    函数名(形式参数列表)     interrupt    n 
中断函数在运行过程中自动完成以下工作：

- 当中断产生时，中断函数被系统调用，ACC、B、DPH、DPL、PSW这些特殊功能寄存器的值将被保存在堆栈中
- 如果中断函数未使用using属性进行修饰，中断函数前使用的寄存器的值将保存在堆栈中
- 中断函数运行完成退出时，堆栈中保存的数据将被恢复
- 中断函数退出时，其对应的汇编代码使用RETI指令退出

==中断函数应遵循以下规则：==

- 中断函数不能进行参数传递
- 中断函数没有返回值
- 不能在其它函数中直接调用中断函数
- 如果在中断中调用了其他函数，必须保证这些函数和中断函数使用了相同的寄存器组，并且这些函数应为可重入函数
- C51编译器从绝对地址8n+3产生一个中断向量，其中n为中断号。该向量包含一个到中断函数入口地址的绝对跳转

# T0和T1的应用举例

例：若fOSC=12MHz，T1工作于方式1，产生50ms的定时中断，TF1为高级中断源。试编写主程序和中断服务程序，使P1.0产生周期为1s的方波
解：让P1.0每500ms取反一次即可实现。定时器的单次定时时间不可能达到500ms，可让定时器多次定时产生500ms的定时时间，如让T1工作在方式1，单次定时时间为50ms，那么T1中断10次就是500ms的时间
（1）确定定时常数
            假设使用fOSC的12分频作为计数源，
            则T计数＝12/fOSC ＝1μs
            由公式TC=M－T/T计数，可知TC
∴TH1与TL0可得

（2）初始化程序
        包括T1初始化和中断系统初始化，主要是对IP、IE、TCON、TMOD的相应位进行正确的设置，并将时间常数送入T1。本例中将初始化操作放在主程序中完成，当程序规模较大时，应编写单独的初始化程序，以利于程序的模块化设计
（3）中断服务程序
         中断服务程序除了完成要求的方波产生这一工作之外，还要注意将时间常数重新送入T1中，为下一次产生中断作准备

```c
sbit P1_0 = P1^0;
int count=10;		//10次T1中断为500ms
void main( void )
{  	TMOD=0x10;  	 	//T1方式1
 	P1_0=0;
   	TH1=0x3c;   		//初值
   	TL1=0xb0;  
   	IE|=0x88;   		//允许T1中断
   	IP|=0x08;   		//TF1中断为高级中断
   	TCON|=0x20; 		//启动T1 
   	While(1);  		//死循环，等待中断，产生方波
}

void Timer1_ISR (void) interrupt 3
{
   TH1=0x3c;    		//重装初值
   TL1=0xb0;
   count--;     	 	//中断计数
   if (count==0) 	//500ms到，重赋计数初值，P1.0取反
   {
      count=10;  P1_0=!P1_0;
   }
}

sbit P1_0= P1^0;

void main( )
{
	int count=10;	//10次T1中断为500ms
	TMOD=0x10;   	//T1方式1
	P1_0=0;
	TR1=1;		//启动T1
	For(; ;) 		//死循环，产生方波
	{
        TH1=-50000/256;   	//T1初值
        TL1=-50000%256;
        Do {} while(!TF1); 	//查询等待TF1置位，
        TF1=0;
        If (count!=0) 
            count--;
        else {count=10;P1_0=!P1_0;}
	}
} 
```

# 串行通信编程举例

例：在单片机的片内数据存储器20H～3FH单元共有32个字节数据，要求使用UART模式1发送出去，传输波特率为9600，设SYSCLK=12MHz。试分别用查询方式和中断方式编写发送程序和相应的接收程序
解：选T1工作于模式2，作为波特率发生器，SMOD0=0，T1的时间常数计算（请同学自己计算）：253（FDH） 

查询方式发送程序

```
void main(void)
{      
	unsigned char i;
    char data *p;   		//发送数据块地址指针
    TMOD=0x20;      		//初始化并启动T1
    TH1=0xfd;
    TL1=0xfd;
    TR1=1;
    SCON=0x40;    		//UART0初始化
    p=0x20;        		   	//地址指针初始化
    for(i=0;i<32;i++)
    {	
        SBUF0=*p;  		//一字节送发送SBUF0
        p++;
        while(!TI);		//等待发送完成
        TI=0;
    }
}

```

查询方式接收程序

```
void main(void)
{ 	
	char data *p;   		//发送数据块地址指针
    unsigned char i;
    TMOD=0x20;      	//初始化并启动T1
    TH1=0xfd;
    TL1=0xfd;
    TR1=1;
    SCON=0x50;    	//UART0初始化，方式1 、允许接收
    p=0x20;        		//地址指针初始化
    for(i=0; i<32; i++)
    {	
    	while(!RI); 	//等待UART0接收一个字符
        RI=0;
        *p=SBUF0;   	//放入接收缓冲区
        p++;
    }
} 

```

中断方式发送主程序

```
char data *p; //发送数据块地址指针
void main(void)
{	 
    TMOD=0x20;     		//初始化并启动T1
    TH1=0xfd;
    TL1=0xfd;
    TR1=1;
    SCON=0x40;   		//UART0初始化，方式1
    p=0x20;      			//地址指针初始化
    EA=1;        			//开中断
    ES0=1;
    SBUF0=*p;   		   	//发送第一个字符
    while(1);   			//等待发送中断
}

```

中断方式发送中断服务程序

```
void interrupt_UART0(void) interrupt 4
{
		TI=0;         		//清发送中断标志
  		p++;
		if(p<0x40)
			SBUF0=*P; 	//发送下一字节
		else 
			ES0=0;   	//关串口中断
}

```

中断方式接收主程序

```
char data *p;    	    //发送数据块地址指针
void main(void)
{     
    unsigned char i;
    TMOD=0x20;      //初始化并启动T1
    TH1=0xfd;
    TL1=0xfd;
    TR1=1;
    SCON=0x50;    //UART0初始化，方式1、允许接收
    p=0x20;        	   //地址指针初始化
    EA=1;          	   //开串口中断
    ES0=1;    
    while(1);     	   //等待接收中断
}

```

中断方式接收中断服务程序

```
void interrupt_UART0(void) interrupt 4
{
	 RI=0;      		//清接收中断标志
   	*p=SBUF0;  		//收到的字符送接收缓冲区
   	p++;
   	if(p>=0x40) ES0=0; 	//关串口中断
}

```

