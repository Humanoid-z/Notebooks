# 51单片机汇编语言简介

汇编语言（Assembly language）是一种低级的计算机编程语言，它直接与计算机的机器码打交道

汇编程序在编译器中汇编之后生成以.HEX为后缀的执行代码文件，执行代码是一系列的十六进制数，与指令一一对应

51单片机的指令分为了算术运算指令、逻辑运算指令、数据传送指令、布尔指令、调用指令、跳转指令、循环指令等

指令格式：

[标号：]  操作码助记符  [第一操作数，]  [第二操作数] [；注释]

# 51单片机汇编语言分类、操作数符号描述、伪指令

## 汇编指令分类

MCS-51系列单片机的指令系统包含==111条指令==，配合与不同的操作数共有255个指令的写法，即255种指令的执行代码。实际应用中，常用的指令一般不过50个
51单片机汇编指令共分五大类：

- 数据传送类（29条）
- 算术运算类（24条）
- 逻辑运算类（24条）
- 控制转移类（17条）
- 位操作类（17条）

按照==占用空间==分三类：
49条单字节指令
45条双字节指令
17条三字节指令
按照==执行时间==分三类：
64条单周期指令
45条双周期指令
2 条四周期指令（即乘、除指令）

## 操作数的描述符号

Rn ————— 工作寄存器R0－R7
Ri ————— 间接寻址寄存器R0、R1
Direct—— 直接地址，包括内部128B RAM单元地址，26个SFR地址
#data —— 8位常数
#data 16 —— 16位常数
addr 16 —— 16位目的地址
addr 11 —— 11位目的地址
rel —— 8位带符号的偏移地址
DPTR —— 16位外部数据指针寄存器
bit  —— 可直接位寻址的位 

A —— 累加器
B —— 寄存器B
C —— 进、借位标志位，或位累加器
@ —— 间接寄存器或基址寄存器的前缀
/  —— 指定位求反
（x）—— x中的内容
（（x））—— x中的地址中的内容
$ —— 当前指令存放的地址 

## 伪指令

伪指令（Pseudo opcode）并不算可执行程序的一部分，所以不会被汇编器汇编，也不生成执行代码，但却告知汇编器一些信息
如常用的伪指令ORG告诉汇编器程序的起始地址、伪指令END表明汇编程序的结束等

==定位伪指令：ORG  m==
m一般为十进制或十六进制数表示的16位地址，用来指定该伪指令后指令或数据的起始存放地址
允许使用多条定位伪指令，但其值不应和前面生成的机器代码或数据的存放地址重叠
在实际应用中的作用是：一般仅设置中断服务子程序和主程序的起始存放地址，其他程序或常数依次存放即可

==汇编结束伪指令：END==
 必须放在源程序末尾，一个源程序只能有一个END
 ==定义字节伪指令：DB==
标号：DB  x1, x2, …, xn
将其右边的数据依次存放到标号为起始地址的存储单元中，xi为字节数据，为二、十、十六进制和ASCII码等多种表示形式。通常用于定义一个常数表
==定义字伪指令：DW==
标号：DW  Y1，Y2，…，Yn
功能与DB类似，但DW定义的是一个字（2个字节），主要用于定义16位地址表（高8位在前，低8位在后）

==定义预留存储空间伪指令DS==
标号：DS  数值表达式
从指定的地址开始，保留若干字节的内存空间作为备用。汇编后，将根据表达式的值决定从指定地址开始留出多少个字节空间，表达式也可以是一个指定的数值
==等值伪指令EQU==
字符名称  EQU  数据或汇编符
“字符名称”被赋值后，在程序中就可以作为一个8位或16位的数据或地址或汇编符来使用。通常等值伪指令放在源程序的开头。注意先定义后使用！

==数据地址赋值伪指令DATA==
字符名称  DATA  表达式
 与EQU类似，是将其右边“表达式”的值赋给左边的“字符名称”。表达式可以是一个8位或16位的数据或地址，也可以是已定义“字符名称”在内的表达式，但不可以是汇编符号
 无先定义后使用的限制，可以用在源程序的开头或末尾
 ==位地址定义伪指令BIT==
字符名称  BIT  位地址
 位地址定义伪指令BIT将其右边位地址赋给左边的字符名

# 51单片机汇编寻址方式

汇编寻址方式是汇编寻找操作数存放单元的地址的方式，共==6种方式==：

1. **立即寻址**
与立即数相关的寻址方式。所要找的操作数是个二进制数或十进制数或十六进制数，立即数的特征就是在数据前加一个“#”号
这类寻址方式比较简单，如以下几条指令都属于立即寻址指令：
	MOV  A,  #100;  将立即数100（64H）载入累加器A中
	MOV  33H,  #10H;  将立即数10H载入数据存储器地址33H中 
	MOV  R0,  #0FFH;  将立即数FFH放入工作寄存器R0中

2. **直接寻址**
直接地址的内容载入一个寄存器中或寄存器的内容载入直接地址中
AT89S51单片机片内数据存储器的00H—7FH（但常用30H—7FH）以及特殊功能寄存器SFR都能被直接寻址。注意地址前是没有“#”号的。如以下几条指令属于直接寻址指令：
         MOV  A, 30H;  把直接地址30H中的内容载入累加器A
         MOV  50H, B;  把B寄存器的值载入直接地址50H中  
         ADD  A, 60H;  累加器A和直接地址60H的内容相加，结果存回
                                  累加器A

3. **寄存器寻址**
寄存器寻址：是指与工作寄存器R0~R7有关的寻址指令。例如：
      MOV  A, R0;  将R0的值载入累加器A                                       
      ADD  A, R5;   将A与R5的值相加，并把结果存回A
      MOV  R7, A;  将A的值载入R7中 
4. **间接寻址**
    间接寻址：用R0、R1、SP、DPTR中的某一寄存器来代替直接寻址中的直接地址来寻址。其中“@”符号表示间接寻址，注意在书写时不要遗漏
    一本书放在甲抽屉中，上了锁；其开锁的钥匙放在乙抽屉中，乙抽屉也上了锁。问如何才能取到那本书？
    间接寻址指令举例：
      MOV  R1, #32H; R1=32H
      MOV  A, @R1; R1所指向的地址的内容载入A累加器中
5. **变址寻址**
    变址寻址：==针对的仅是程序存储器==，而且这种寻址方式只能从程序存储器中读数据。通常对程序存储器访问得较多的是数据表中的数据（比如取表法）
    在变址寻址中，使用程序计数器PC或数据指针DPTR作为间接地址，有时还加上累加器A，根据这些间接地址在程序存储器找到相应的内容
    操作数地址 = 变地址 + 基地址
    基地址寄存器     DPTR 或 PC 
    变址寄存器      @A
    例如：MOVC  A, @A+DPTR;  累加器A和数据指针DPTR之和作为间接地址，将该地址上的数据载入A中
6. **寄存器特征寻址**
    寄存器特征寻址：与特定寄存器有关的寻址方式。有些指令总是与累加器A或数据指针寄存器DPTR等有关，而没有涉及其他地址
    这类指令只影响特定寄存器，不会改变其他地址或寄存器。如以下几条指令属于寄存器特征寻址指令：
     INC   A;         累加器A自增1                                         
     SWAP  A;      A的高4位与低4位互换                               
     INC  DPTR;   数据指针DPTR自增1

# 51单片机汇编数据传送类指令

![image-20201027201040901](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027201040901.png)

1、==片内数据装载指令——MOV 　\<dest>, \<src>==
数据装载指令以MOV为助记符，其中\<dest>为目的操作数，\<src>为源操作数。\<dest>和\<src>代表==片内==数据存储器地址或特殊功能寄存器，**指令在进行不同地址空间或寄存器之间装载时不需要通过累加器A的参与**

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027201316848.png" alt="image-20201027201316848" style="zoom:67%;" />

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027201340857.png" alt="image-20201027201340857" style="zoom:67%;" />

注意：上述指令不影响任何标志位，但**PSW**的P位除外！

![image-20201027201435636](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027201435636.png)

需要特别注意：
            MOV  Rn，Rn              
            MOV  @Ri, @Ri
            MOV  Rn,     @Ri
            MOV  #data,  A
           等等指令都是==**非法指令**==！ 

![image-20201027201804318](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027201804318.png)

2、堆栈指令——PUSH、POP

![image-20201027201629451](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027201629451.png)

说明：堆栈是单片机在**片内数据存储器**中开辟的用于保存临时数据的区域。堆栈的地址由堆栈指针SP来指向，SP是一个特殊功能寄存器，上述指令的执行不影响任何标志位！
   PUSH  direct 指令执行中，机器自动进行两步操作：
（1）     SP                 （SP）+ 1
（2）（SP）             （direct）
  POP   direct  指令执行中，机器也自动进行两步操作：
（1）（direct）              （（SP））
（2）	    SP                 （SP）－ 1

堆栈操作的结论：
      1）堆栈指针SP总是指向最后一次使用的堆栈的地址
      2）PUSH 与 POP 操作过程刚好相反
      3）进、出栈规则：先进后出，后进先出。应注意指令书写先后顺序；
      4）可用于“保护现场，恢复现场”

![image-20201027201746599](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027201746599.png)

![image-20201027201853040](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027201853040.png)

3、**数据交换指令**
在累加器A与==工作寄存器==之间、累加器A与==直接地址==之间、累加器A与间接地址之间可以进行**直接数据交换**

![image-20201027202318194](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027202318194.png)

4、**片外数据装载指令——MOVX** 　\<dest>, \<src>

单片机自身的程序存储器或数据存储器在实际应用中有可能不够用，于是可以在单片机之外添加适当的存储器芯片以扩展程序或数据的存储空间
一旦扩展片外存储器，就会涉及到寻址片外存储器的情况，而应付这类情况有专门的指令

![image-20201027202443266](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027202443266.png)

片外数据装载指令主要用于访问扩展的片外存储器，片外存储器可以是RAM、ROM、Flash等类型。而且从上表可知所有的指令都是间接寻址的（因为有符号“@”），前两个指令将Ri（R0或R1）或DPTR所指向的片外存储器地址的内容载入单片机的累加器A中，后两条指令相反，把累加器A的数据写到Ri（R0或R1）或DPTR所指向的片外存储器的地址上

当使用Ri间接寻址时，**因为Ri只有1个字节，所以寻址范围为00H\~FFH。如果使用的是DPTR寻址则可寻址更大的范围0000H~FFFFH**。至于程序中选择使用Ri还是DPTR要根据片外存储器的容量来确定。使用DPTR寻址空间范围大，但参与寻址的地址线可多达16位，这样除P0口全部用作地址线外，P2口也会被部分或全部占用

执行过程中会使/WR、/RD有效

**例题：试编写一程序段，实现将片内RAM存储器0FAH单元中的内容传送到片外RAM存储器04FFH单元中**

解：    MOV  DPTR，#04FFH
            MOV  R0，#0FAH
            MOV  A，@R0
            MOVX  @DPTR, A 

5、查表指令
查表操作实际上是把**程序存储器**里的数据通过累加器A后供程序中使用，由于查表操作访问的是程序存储器，所以查表指令只提供了读的操作

![image-20201027203023774](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027203023774.png)

在执行指令“MOVC  A, @A+DPTR”前，数据指针DPTR一般都会先载入数据表，使用的指令一般为“MOV  DPTR, #TABLE”，其中“TABLE”为数据表的标号。这样DPTR就指向数据表的表头地址，查表指令就可以把数据表中的数据载入A中

**例题：设（A）= 一个BCD码常数，用查表法获得其相应的ASCII码**

解法I：      MOV  DPTR，#TAB
                    MOVC  A，@A+DPTR
        TAB：DB 30H，31H，32H，33H，34H，35H 
                           ······

解法II：     MOVC  A，@A+PC
        TAB：DB 30H，31H，32H，33H， 34H，35H，
	               36H，37H
                            ······ 

练习题目：
1. R0的内容传送到R1
2. 内部RAM地址20H的单元内容传送到内部RAM地址30H的单元
3. 外部RAM地址20H单元的内容传送到内部RAM地址20H的单元
4. 外部RAM地址2000H单元的内容传送到内部RAM地址20H的单元
5. 外部ROM地址2000H单元的内容传送到内部RAM地址40H的单元
6. 外部ROM地址2000H单元的内容传送到外部RAM地址3000H的单元 

# 51单片机汇编算术运算指令

包括：加、 减、乘、除；加一、减一
1、加法指令——ADD  A, <src-byte>；在单片机做加法运算时，都要涉及累加器A
指令中“A”代表累加器A，“<src-byte> ”代表“源操作数-以字节形式”
根据源操作数<src-byte>的不同，加法指令有4种指令形式

![image-20201027204249834](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027204249834.png)

说明：
① 相加的操作总是在累加器A中发生，源操作数可以是一个工作寄存器的值、直接地址的内容、间接地址的内容或立即数。注意：两个直接地址的内容相加是不允许的
② 加法指令有可能影响程序状态字PSW中的标志位CY、OV、AC、P。如果相加过程中，位3（低位）有进位则辅助进位标志位AC=1；位7（高位）有进位则进位标志位CY=1
③ 溢出标志位OV的变化规律是：如果位6有进位而位7没有进位，或者位7有进位而位6没有，则溢出标志OV=1，否则OV=0。注意，OV的状态只有在带符号数加法运算时才有意义

例题：执行以下两行指令，观察标志位的变化。
	MOV     A, #0F5H        ; A=0F5H

​	ADD      A, #0BH         ; A=0F5+0BH=00H，CY=1，AC=1
运算过程：

![image-20201027204341384](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027204341384.png)

运算结果：
A=00，标志位情况如下：

CY=1——由于位7有进位

AC=1——由于位3向位4进位

P=0——由于运算结果A=0000 0000，其中1的个数是0（偶数），所以P=0

2、带进位的加法指令——ADDC  A, <src-byte>
带进位的加法指令相当于在加法运算之后再**加上进位CY**，如果CY=0，结果不变；如果CY=1，结果加1。其带进位的加法指令形式与加法指令相似

![image-20201027205242502](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027205242502.png)

例题：写一段汇编程序作3CE7H和3B8DH的加法运算，将运算结果的低位字节存到R0中，高位字节存到R1中。
程序：

![image-20201027205723194](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027205723194.png)

运算结果：R1=78H，R0=74H
注意：1.双字节加法；2.ADDC带进位的加法

3、带借位的减法指令——SUBB  A,\<src-byte>
在单片机做减法运算时，也要涉及累加器A。当单片机进行减法运算时，程序状态字PSW中的CY位就变成了借位标志位，即如果减法运算过程中有借位发生，CY被硬件置1。由于SUBB指令是带借位的减法指令，于是在运算中就需要考虑CY对运算的影响

![image-20201027205908518](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027205908518.png)

带借位的减法指令说明：
①当位7有借位时，标志CY=1；否则CY=0。也就是说，如果无符号数做减法时，减数比被减数大，CY=1
②当位3有借位时，标志AC=1；否则AC=0
③溢出标志位OV=1表示溢出；OV=0表示未溢出。OV的值可由差的位7的借位与位6的借位做XOR（异或）的逻辑判断得到
④由于SUBB指令连CY一起减，若不想减CY，可先将CY清0

5、自增/自减指令——INC  <byte> / DEC  <byte>
自增/自减指令是一类很简单的指令，它的作用是对寄存器的值或直接地址的内容进行加1/减1的操作

![image-20201027210004272](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210004272.png)

自增/自减指令说明：
① 如果寄存器的值或直接地址的内容为FFH时，执行自增指令INC后，寄存器的值或直接地址的内容变为00H，进位标志CY不受影响
② 如果寄存器的值或直接地址的内容为00H时，执行自减指令DEC后，寄存器的值或直接地址的内容变为FFH，进位标志CY不受影响
③ 关于指令“INC  DPTR”，若DPTR的低位字节DPL=FFH，执行“INC  DPTR”后DPL=00H，同时高位字节DPH的值增加1，CY不受影响；如果DPTR=FFFFH，执行“INC  DPTR”后，DPTR=0000H，CY也不受影响
④ 可对DPL和DPH分别进行自增INC或自减DEC的操作

6、乘法指令——MUL	A B
乘法运算只针对累加器A和B寄存器中的无符号整数，运算得到的乘积长度为2个字节，其低位保存在累加器A中，高位保存在B寄存器中。乘法指令会对标志位有所影响

![image-20201027210035834](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210035834.png)

说明：
① 如果乘法运算结果大于00FFH，OV=1，否则OV=0
② 执行乘法运算时，进位标志CY会被清除为0

例题：执行下面的乘法指令，观察标志位的变化。

​         MOV		A, #66H        ; A=66H

​         MOV     	B, #77H        ; B=77H

​         MUL		AB	          ; 积=66H×77H=2F6AH

运算结果：

A=6AH，B=2FH，CY=0，由于2F6AH>00FFH，所以OV=1

7、除法指令——DIV  A B（除法用减法来实现，减法用加法来实现）
除法指令将累加器A中的无符号数除以B寄存器中的无符号数，商保存回累加器A，余数保存回B寄存器。除法指令影响标志位

![image-20201027210125189](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210125189.png)

说明：
① 除法指令做无符号的除法运算。如果B寄存器=0，执行时OV被置1，表示运算是错误的，因为除数不应该为0
② 除法指令正确执行后，商存回A，余数存回B寄存器，进位标志CY及溢出标志OV都等于0

除法指令程序举例

![image-20201027210136393](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210136393.png)

8、十进制调整指令——DA  A
十进制调整指令常用在加法指令（ADD和ADDC）之后对结果进行十进制调整，但不能使用在如INC等指令之后

![image-20201027210150891](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210150891.png)

说明：
① 在加法（ADD）或带进位的加法（ADDC）运算后，若累加器A的**低位>9或AC=1**，则A+06H
② 在加法（ADD）或带进位的加法（ADDC）运算后，若累加器A的**高位>9或CY=1**，则A+60H

# 51单片机汇编逻辑运算指令

共分两大类：单字节逻辑操作，双字节逻辑操作，共24条
1、与操作——ANL  \<dest-byte>,  \<src-byte>
与操作的功能与数字电路中的与门相似只有两个操作数都是1时，与操作的结果才是1
指令中的<dest-byte>代表“目的操作数-以字节形式”，<src-byte>代表“源操作数-以字节形式”

![image-20201027210229150](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210229150.png)

说明：以上指令对两个操作数的每一位进行与操作，只有两个操作数同一位都是1，该位与操作的结果才是1，结果存回目的操作数中
例如：

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210247038.png" alt="image-20201027210247038" style="zoom:80%;" />

2、或操作——ORL  <dest-byte>,<src-byte>
或操作的功能与数字电路中的或门相似，只要有一个操作数是1，或操作的结果就是1

![image-20201027210312930](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210312930.png)

说明：以上指令对操作数的同一位进行或操作，两个操作数的同一位只要有一个是1，或操作的结果就是1，结果存回目的操作数中
例如：![image-20201027210342961](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210342961.png)

3、异或操作——XRL	 <dest-byte>,<src-byte>
异或操作的功能与数字电路中的异或门相似，如果两个操作数相同，异或操作的结果为0，否则为1

![image-20201027210400222](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210400222.png)

说明：以上指令对操作数的同一位进行异或操作，两个操作数的同一位都为0或1时异或操作结果为0，否则结果是1，结果存回目的操作数中
例如：![image-20201027210407874](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210407874.png)

累加器A清0操作——CLR  A

![image-20201027210420509](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210420509.png)

累加器A取反操作——CPL  A(Converse Position Logical)

![image-20201027210432269](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210432269.png)

累加器A位移动操作——RL、RLC、RR、RRC

![image-20201027210437449](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210437449.png)

说明：这4条指令用于累加器A内部位的移动，注意，这4条指令只适用于累加器A
① RL  A——累加器A左移一位。每次移出累加器A的位7进入位0

![image-20201027210501503](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210501503.png)

② RLC  A——累加器A含进位CY左移一位。每次移出累加器A的位7进入进位CY中，而进位CY则进入位0中

![image-20201027210521158](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210521158.png)

③ RR  A——累加器A右移一位。每次移出累加器A的位0进入位7

![image-20201027210529405](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210529405.png)

④ RRC  A——累加器A含进位CY右移一位。每次移出累加器A的位0进入进位CY中，而进位CY则进入位7中

![image-20201027210534186](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210534186.png)

累加器A高低位交换操作——SWAP  A
累加器A长度为一个字节，高低位交换操作将把累加器A的高位和低位字节进行交换

![image-20201027210545613](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210545613.png)

![image-20201027210549894](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210549894.png)

## 布尔指令

清0、置1、取反操作——CLR、SETB、CPL

![image-20201027210603728](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210603728.png)

布尔逻辑运算指令——ANL、ORL

![image-20201027210631395](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210631395.png)

位数据装载指令——MOV  <dest-bit>,<src-bit>

![image-20201027210639907](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210639907.png)

布尔跳转指令——JC、JNC、JB、JNB、JBC

![image-20201027210717151](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210717151.png)

![image-20201027210726748](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027210726748.png)

**例题：比较内部RAM的30H和40H单元中的两个无符号数的大小，将大数存入20H单元，小数存入21H单元，若二数相等，则使内RAM的第127位置1**

```汇编
    MOV  A，30H
    CJNE  A，40H，LOOP1;比较不相等转移指令
    SETB  7FH
    SJMP  $
LOOP1： JC    LOOP2
    MOV  20H，A
    MOV  21H，40H
    SJMP  $
LOOP2： MOV  20H，40H
    MOV  21H，A                      
    SJMP  $ 
```


# 51单片机汇编控制转移类指令

控制转移类指令作用：改变程序计数器PC的值，从而改变程序执行方向
分为四大类：**无条件转移指令、条件转移指令、调用指令、返回指令**
**1、无条件跳转指令包含四个：LJMP、AJMP、SJMP、JMP**
当执行到无条件跳转指令时，单片机会立即跳到特定地址上执行，并不需要判断什么情况

![image-20201027211010265](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211010265.png)

说明：

1. 以上4个跳转指令都是无条件跳转指令。其中LJMP是长跳转指令，指令长度为**3个字节**，第1个字节为LJMP助记符的执行代码02H，**后两个字节**是所要跳转的目标地址。因为有两个字节来指定目标地址，所以LJMP跳转地址范围达64K Bytes，即0000～FFFFH
2. AJMP是绝对跳转指令，指令长度为**2个字节**，助记符01H占一个字节，因只有**一个字节**来指向跳转的目标地址，所以目标地址不超过2K Bytes
3. AJMP与LJMP的执行机制相同，唯一的不同就是跳转的目标地址范围不同。如果判断**目标地址小于2K Bytes**，应当尽量使用AJMP指令以节省1个字节的存储空间
4. SJMP是一个相对跳转指令，跳转范围为**向前128个字节，向后127个字节**。向前就是跳转到比当前程序计数器PC所指的地址要小的地址上去执行，向后则相反，跳转到比当前PC所指的地址要大的地址上去执行
5. JMP则是一个笼统的跳转指令，它会自动判断跳转的范围从而选择是使用1个字节还是2个字节来指向跳转的目标地址，在程序中如果**不清楚跳转的范围**可以简单地使用JMP指令

![image-20201027211149032](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211149032.png)

2、条件跳转指令——JZ、JNZ

<img src="C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211213877.png" alt="image-20201027211213877"  />

条件跳转指令需要满足一定的条件才会发生跳转，这个条件就是累加器A的状态
说明：条件跳转指令有两条对立的指令，一是JZ指令，当累加器A=0时跳转。二是JNZ指令，当A≠0时才跳转

3、比较跳转指令——CJNE  <dest-byte>, <src-byte>, rel
比较跳转指令可将累加器A、Rn、间接地址的内容与一个具体的立即数比较，如果不相等就发生跳转

![image-20201027211247754](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211247754.png)

CJNE将源操作数<src-byte>与目的操作数<dest-byte>进行比较，如果不相等就跳转到rel所指的地址。比较跳转指令CJNE集成了两种操作——比较和跳转
此外，它还会改变进位标志CY的值以显示目的操作数较大还是较小。CJNE指令不会改变源操作数或目的操作数的值

![image-20201027211311690](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211311690.png)

![image-20201027211323308](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211323308.png)

**例题：将片外RAM的一个数据块（首地址为DATA1）传送到内部数据RAM（首地址为DATA2），遇到传送的数据为零时停止传送，请编程**

解：           MOV  R0，#DATA2
                   MOV  DPTR，#DATA1
LOOP1： MOVX  A，@DPTR
                   JZ   LOOP2
                   MOV  @R0，A
                   INC  R0
                   INC  DPTR
                   SJMP  LOOP1
LOOP2：  SJMP  LOOP2 

**例题：设P1口的P1.0 ~ P1.3为准备就绪信号输入端，当该四位为全1时，说明各项工作已准备好，单片机可顺序执行，否则，循环等待**

解：WAIT:  MOV  A，P1
                      ANL   A，#0FH
                      CJNE  A，#0FH，WAIT  ;P1.0 ~ P1.3不为全1时，返回WAIT
                      MOV  A，R2
             ……… 

4、循环指令——DJNZ  <byte>,<rel-addr>
循环可以实现延时、判断等功能，可以让一段程序重复执行若干次，提高程序执行效率

![image-20201027211438618](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211438618.png)

说明：通过循环指令DJNZ来构造循环体是一种最广泛程序设计的方法。循环指令DJNZ执行时，工作寄存器或直接地址内容减1，如果不等于0，则程序跳转到rel指示地址。在执行DJNZ指令前，需要向相关工作寄存器或地址中载入计数值，该计数值就是循环的次数

![image-20201027211448717](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211448717.png)

**例题：将8031内部RAM的40H ~ 4FH单元置初值#A0H ~ #AFH**

解：            MOV  R0，#40H
                    MOV  R2，#10H
                    MOV  A，#0A0H
     LOOP：MOV  @R0，A
                    INC  R0
                    INC  A
                    DJNZ  R2，LOOP
                           ……… 

5、调用子程序指令
长调用指令——LCALL

![image-20201027211538604](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211538604.png)

说明：
长调用指令LCALL的执行代码占用3个字节，第1个字节为LCALL助记符12H，后两个字节是所要调用子程序的目标地址，因为有两个字节来指定子程序的目标地址，所以调用的范围可达64K Bytes，即地址0000H～FFFFH
为了确保子程序执行完毕之后单片机能正确回到主程序继续执行**，LCALL执行时会把它下一条指令的地址保存在堆栈中。**当遇到子程序返回指令RET后单片机将堆栈中保存的地址弹出，并据此继续主程序的执行

![image-20201027211706098](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211706098.png)

绝对调用指令——ACALL

![image-20201027211720353](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211720353.png)

绝对调用指令ACALL的长度为2个字节，2个字节中有11位用来指向子程序的地址，所以说子程序的目标地址不能超过2K Bytes的范围
ACALL与LCALL的执行机制相同，唯一的不同就是调用目标地址范围不同

如果判断子程序目标地址在2K Bytes范围内，应当尽量使用ACALL指令以减少程序存储空间的浪费
如果单片机支持CALL指令（如AT89S51就支持），完全可以使用CALL来笼统地调用子程序，因为它会自动判断调用的范围从而选择是使用1个字节还是2个字节来指向子程序的目标地址

6、返回指令——RET、RETI
当子程序或中断服务子程序执行完后，需要返回指令告诉单片机返回主程序。返回指令是必需的，否则单片机不知道子程序是否执行完

![image-20201027211753340](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211753340.png)

返回指令**RET**用于子程序的末尾，**提示子程序结束**，以返回主程序。前面所有调用子程序的程序中都使用RET返回
返回指令**RETI**用于**中断服务子程序结束**，在介绍中断的章节中会发现，在中断服务子程序末尾都会有RETI指令

![image-20201027211919801](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211919801.png)

7、无操作指令——NOP

![image-20201027211934542](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201027211934542.png)

说明：
无操作指令NOP没有操作数，不产生任何影响，只是在耗费时间，同时会更新程序计数器PC的计数值
每执行一次NOP指令花去1个机器周期，执行完NOP后，就接着执行下一条指令
NOP指令常常用在等待一个很短的时间（若干个机器周期时间，几µs），比如在等待外设的操作等

# 51单片机汇编汇语言及汇编过程

**汇编指令与机器码指令有一一对应的关系**
汇编程序是一种翻译程序，将源程序翻译成目标程序

汇编有两种方法：手工汇编、机器汇编
1. 手工汇编：
第一次汇编：**确定地址，翻译成各条机器码**，字符标号原样写出
第二次汇编：标号代真，**将字符标号用所计算出的具体地址值或偏移量代换**

![image-20201105164553914](C:\Users\12548\Documents\GitHub\Notebooks\课程笔记\单片机\第8讲 51单片机与汇编指令.assets\image-20201105164553914.png)

注意：
单片机要先取址PC+1后执行代码，因此要执行代码，PC的值肯定是加1之后的
单片机的减法用加法实现，具体操作是加负数的补码，而补码由反码加1来实现！

2. 机器汇编
两次扫描过程
第一次扫描：1.检查语法错误，确定符号名字
                                2.建立使用的全部符号名字表
                                3.每一符号名字后跟一对应值（地址或数）
第二次扫描：1.是在第一次扫描基础上，将符号地址转换
                                2.成地址（代真）
                                3.利用操作码表将助记符转换成相应的目标码 

## 查表程序设计

查表代替计算有以下好处：
1. 程序简单、清晰、可读性好
2. 执行速度快

查表步骤

1. 用DPTR作基地址查表
       MOVC    A, @A+DPTR      ;A<-((A)+(DPTR))
      步骤: (1) 所查的表的基地址－>DPTR
                 (2) 所查的表项－>A
                 (3) 执行查表指令
2. 用PC作基地址查表
       MOVC    A, @A+PC           ;A<-((A)+(PC))
      步骤:(1) 所查表的项数－>A
                (2) 对A进行修正：ADD   A,#data
                   其中 data=查表指令与表首地址间字节数
                (3) 执行查表指令

例题：已知R0中有一个0～F的数据，通过查表把它转换成ASCII码。

方法一：采用DPTR作为基指针
               ORG  0000H                   ;伪指令指明复位入口
               LJMP  MAIN                   ;复位执行的第一条指令
               ORG  0100H                   ;主程序从该地址开始
   MAIN:  MOV  DPTR,#ASCIITAB   ;表首址给DPTR
                MOV  A,R0                        ;要查的项数给A
                ANL   A,#0FH                    ;屏蔽掉高四位
                MOVC   A,@A+DPTR       ;执行查表指令转换为ASCII码
                MOV  R0,A                        ; (A)->R0
                SJMP  $
  ASCIITAB:  DB  ‘0’,’1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’
                      DB  ‘A’,’B’,’C’,’D’,’E’,’F’
                 END

方法二：采用PC作基指针查表
ORG  0000H
                   LJMP  MAIN
                   ORG  0100H
     MAIN:   MOV  A,R0                 ;表项数给A
                  ANL   A,#0FH             ;屏蔽掉高四位
                   ADD  A,#03H             ;修正A
                   MOVC  A,@A+PC     ;执行查表
                   MOV  R0,A                 ;(A)->R0，占用1个字节
                   SJMP  $                      ;占用2个字节
  ASCIITAB: DB ‘0’ ‘1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’
                      DB ‘A’,’B’,’C’,’D’,’E’,’F’
                   END